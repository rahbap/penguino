<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Penguin Warlord: Skins Update</title>
    <style>
        body { margin: 0; background: #001122; color: #004466; font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        
        canvas { 
            display: block; cursor: crosshair; margin-right: 300px; 
            background: radial-gradient(circle at 50% 50%, #f0faff 0%, #dbeeff 60%, #b3d9ff 100%);
        }
        
        /* UI PANEL */
        #lab-panel {
            position: absolute; right: 0; top: 0; bottom: 0; width: 300px;
            background: linear-gradient(to bottom, #101a25, #050a10); 
            border-left: 4px solid #55aaff;
            padding: 15px; display: flex; flex-direction: column;
            color: white;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        h2 { color: #55aaff; margin: 15px 0 5px 0; font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #335577; padding-bottom: 5px; }
        .resource { font-size: 24px; color: #00ffaa; font-weight: bold; margin-bottom: 5px; }
        
        .inventory-section {
            flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px;
            max-height: 25%; padding-right: 5px; margin-bottom: 10px;
        }
        
        .ultra-header { color: #ffaa00; border-color: #aa5500; text-shadow: 0 0 10px #ffaa00; }
        .ultra-section { flex-grow: 1; overflow-y: auto; max-height: 25%; border-bottom: 1px solid #333; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #335577; border-radius: 3px; }

        .dna-item {
            background: #253545; padding: 8px; border-radius: 6px; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #334455; transition: 0.2s; font-size: 13px;
        }
        .dna-item:hover { background: #304050; border-color: #55aaff; }
        .dna-item.selected { border: 2px solid #00ffaa; background: #1a3a4a; box-shadow: 0 0 15px rgba(0,255,170,0.3); }
        .dna-item.ultra { border: 1px solid #aa6600; background: #2a1a00; }
        
        #unit-inspector {
            height: 250px; background: #101820; border-radius: 8px; padding: 10px;
            border: 1px solid #335577; display: none; flex-direction: column; margin-top: auto;
        }
        
        #slot-container { display: grid; gap: 3px; margin-bottom: 10px; overflow-y: auto; }
        .slot { background: #000; padding: 4px; border: 1px dashed #446688; border-radius: 3px; font-size: 11px; color: #6688aa; }
        .slot.filled { border: 1px solid #55aaff; color: #fff; background: #003344; }
        .slot.ultra-filled { border: 1px solid #ffaa00; color: #ffaa00; background: #331100; font-weight: bold; }

        button {
            background: #55aaff; color: #002233; border: none; padding: 10px;
            font-weight: bold; cursor: pointer; margin-top: auto; border-radius: 6px;
            text-transform: uppercase; transition: 0.2s; font-size: 12px;
        }
        button:hover:not(:disabled) { background: #88ccff; box-shadow: 0 0 15px #55aaff; }
        
        /* MENUS */
        .overlay-menu {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 15, 30, 0.95); display: flex; align-items: center; justify-content: center; flex-direction: column; z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        .menu-title { font-size: 60px; color: #00aaff; font-weight: 900; margin-bottom: 30px; text-shadow: 0 0 20px #0055aa; letter-spacing: 5px; }
        
        .menu-btn {
            background: linear-gradient(45deg, #0088cc, #0055aa); color: white; border: 2px solid #00aaff;
            padding: 15px 50px; font-size: 24px; font-weight: bold; margin: 10px; cursor: pointer;
            width: 300px; text-align: center; border-radius: 5px; transition: 0.3s;
            box-shadow: 0 0 15px rgba(0,100,255,0.3);
        }
        .menu-btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(0,200,255,0.6); }

        #skin-container { display: flex; gap: 20px; margin-top: 20px; }
        .skin-card {
            background: #102030; border: 2px solid #335577; padding: 20px; border-radius: 10px;
            cursor: pointer; text-align: center; width: 100px; transition: 0.3s;
        }
        .skin-card:hover { border-color: #fff; transform: translateY(-5px); }
        .skin-card.active { border-color: #00ffaa; background: #1a3a2a; box-shadow: 0 0 20px rgba(0,255,170,0.2); }
        .skin-preview { width: 50px; height: 50px; border-radius: 50%; margin: 0 auto 10px auto; border: 2px solid white; }

        #exit-btn {
            position: absolute; top: 10px; right: 320px; z-index: 50;
            background: #ff4444; color: white; padding: 8px 15px; border-radius: 4px;
            font-weight: bold; cursor: pointer; border: 1px solid #aa0000;
        }
        #exit-btn:hover { background: #ff6666; }

        #boss-warning {
            position: absolute; top: 20%; left: 0; right: 300px; text-align: center;
            font-size: 60px; font-weight: 900; color: #ff0000; text-shadow: 0 0 20px black;
            display: none; pointer-events: none; letter-spacing: 5px; z-index: 15;
        }
    </style>
</head>
<body>

    <div id="main-menu" class="overlay-menu">
        <div class="menu-title">PENGUIN WARLORD</div>
        <div class="menu-btn" onclick="startGame()">PLAY GAME</div>
        <div class="menu-btn" onclick="openShop()">SKIN SHOP</div>
    </div>

    <div id="shop-menu" class="overlay-menu" style="display:none;">
        <div class="menu-title" style="font-size: 40px;">BARRACKS SKINS</div>
        <div id="skin-container">
            </div>
        <div class="menu-btn" onclick="closeShop()" style="margin-top: 40px; background: #444; border-color: #666;">BACK</div>
    </div>

    <div id="game-over-menu" class="overlay-menu" style="display:none; background: rgba(20,0,0,0.9);">
        <div class="menu-title" style="color:#ff4444">COLONY LOST</div>
        <div class="menu-btn" onclick="showMainMenu()">MAIN MENU</div>
    </div>

    <button id="exit-btn" onclick="showMainMenu()" style="display:none;">EXIT TO MENU</button>
    <div id="info-overlay" style="position:absolute; top:10px; left:10px; pointer-events:none; color:#004466; font-weight:bold; z-index:5;">
        Difficulty: <span id="diff-disp">1</span> | Timer: <span id="time-disp">00:00</span>
    </div>

    <div id="boss-warning">⚠️ TITAN APPROACHING ⚠️</div>

    <div id="lab-panel">
        <h2 style="margin-top:0">Biomass</h2>
        <div id="bioDisplay" class="resource">1000</div>
        
        <h2>Standard DNA</h2>
        <div id="dna-inventory" class="inventory-section"></div>

        <h2 class="ultra-header">Ultra Vault</h2>
        <div id="ultra-inventory" class="inventory-section ultra-section"></div>

        <div id="unit-inspector">
            <h3 id="inspector-title" style="margin:0 0 5px 0; font-size:14px; color:#55aaff; border-bottom:1px solid #333;">Modding</h3>
            <div id="slot-container"></div>
            <div id="multi-select-info" style="display:none; color:#aaa; font-size:11px; margin-bottom:10px;"></div>
            <button id="btnInject" onclick="injectMutation()">INJECT GENE</button>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth - 300; 
canvas.height = window.innerHeight;

// -- SKINS SYSTEM --
const SKINS = {
    DEFAULT: { name: 'Standard', ally: '#0077aa', enemy: '#cc4444', glow: 'cyan' },
    MAGMA: { name: 'Magma', ally: '#ff4400', enemy: '#00ccff', glow: 'orange' },
    CYBER: { name: 'Cyber', ally: '#00ff00', enemy: '#ff00ff', glow: 'lime' },
    GOLD: { name: 'Midas', ally: '#ffd700', enemy: '#333333', glow: 'yellow' }
};
let currentSkin = 'DEFAULT';

// -- MUTATIONS DATABASE --
const MUTATIONS = {
    LASER: { name: 'Laser Eyes', color: '#ff0055', type: 'range' },
    BEAM: { name: 'Death Ray', color: '#00ccff', type: 'range' },
    SHOTGUN: { name: 'Snow Blaster', color: '#ffffff', type: 'range' },
    SNIPER: { name: 'Icicle Sniper', color: '#00ff00', type: 'range' },
    MISSILE: { name: 'Fish Missile', color: '#ffaa00', type: 'range' },
    SPIKES: { name: 'Spiked Armor', color: '#555555', type: 'melee' },
    SAW: { name: 'Buzz Saw', color: '#cccccc', type: 'melee' },
    SHIELD: { name: 'Bubble Shield', color: '#00ffff', type: 'tank' },
    HEALER: { name: 'Medic Aura', color: '#00ffaa', type: 'support' },
    TESLA: { name: 'Shock Coil', color: '#ffff00', type: 'melee' },
    REPULSE: { name: 'Wind Blower', color: '#ff00ff', type: 'tank' },
    BLINK: { name: 'Teleporter', color: '#aa00ff', type: 'melee' },
    FLAME: { name: 'Flamethrower', color: '#ff4400', type: 'range' },
    // NEW 5 MUTATIONS
    RICOCHET: { name: 'Bounce Shot', color: '#8800ff', type: 'range' },
    BERSERK: { name: 'Berserker', color: '#aa0000', type: 'melee' },
    GRAVITY: { name: 'Gravity Well', color: '#220044', type: 'support' },
    NOVA: { name: 'Frost Nova', color: '#aaddff', type: 'death' },
    GHOST: { name: 'Phantom', color: '#dddddd', type: 'support' }
};

const ULTRA_MUTATIONS = {
    BLACK_HOLE: { name: 'Black Hole', color: '#220033', desc: 'Sucks enemies in' },
    METEOR: { name: 'Meteor Swarm', color: '#ff4400', desc: 'Rains fire from sky' },
    NECRO: { name: 'Necromancy', color: '#00ff44', desc: 'Spawns skeletons' },
    OMNI: { name: 'Omni-Blaster', color: '#ffffff', desc: 'Shoots 360 degrees' },
    TIME: { name: 'Time Freeze', color: '#0000ff', desc: 'Stops enemies' },
    VAMP: { name: 'Vampirism', color: '#aa0000', desc: 'Heals on hit + Speed' },
    GIGA_LASER: { name: 'Orbital Cannon', color: '#ff00aa', desc: 'Giant laser from sky' },
    THOR: { name: 'Thunder God', color: '#ffffaa', desc: 'Chain lightning' },
    NUKE: { name: 'Nuclear Core', color: '#00ff00', desc: 'Passive radiation dmg' },
    DIVINE: { name: 'Divine Shield', color: '#ffd700', desc: 'Reflects damage' }
};

const STD_KEYS = Object.keys(MUTATIONS);
const ULTRA_KEYS = Object.keys(ULTRA_MUTATIONS);

// -- GAME STATE --
let gameState = 'MENU'; // MENU, PLAY, SHOP, OVER
let biomass = 1000;
let frame = 0;
let difficulty = 1;
let army = [];
let enemies = [];
let items = []; 
let projectiles = [];
let particles = [];
let minions = []; 
let inventory = {}; 
let selectedUnits = []; 
let selectedDNA = null;
let isDragging = false;
let dragStart = {x:0, y:0};
let dragCurrent = {x:0, y:0};

// -- ICE BACKGROUND --
const iceCracks = [];
const icePatches = [];
function generateIce() {
    iceCracks.length = 0; icePatches.length = 0;
    for(let i=0; i<15; i++) {
        let x = Math.random()*canvas.width, y = Math.random()*canvas.height;
        let crack = [{x,y}];
        let len = 5+Math.random()*10, angle = Math.random()*6.28;
        for(let j=0; j<len; j++) {
            x+=Math.cos(angle)*20; y+=Math.sin(angle)*20; angle+=(Math.random()-0.5);
            crack.push({x,y});
        }
        iceCracks.push(crack);
    }
    for(let i=0; i<8; i++) icePatches.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, r: 50+Math.random()*100});
}
generateIce();

// -- MENU & UI LOGIC --
function showMainMenu() {
    gameState = 'MENU';
    document.getElementById('main-menu').style.display = 'flex';
    document.getElementById('game-over-menu').style.display = 'none';
    document.getElementById('shop-menu').style.display = 'none';
    document.getElementById('exit-btn').style.display = 'none';
    document.getElementById('boss-warning').style.display = 'none';
    // Clear game
    army = []; enemies = []; items = []; projectiles = []; particles = []; minions = [];
}

function startGame() {
    gameState = 'PLAY';
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('exit-btn').style.display = 'block';
    
    // Reset Game Stats
    biomass = 1000; frame = 0; difficulty = 1;
    STD_KEYS.forEach(k => inventory[k] = 0);
    ULTRA_KEYS.forEach(k => inventory[k] = 0);
    inventory['LASER'] = 5; inventory['SPIKES'] = 5; inventory['HEALER'] = 2;
    renderInventory();
    
    // Spawn initial army
    for(let i=0; i<10; i++) army.push(new Creature(100 + (i%3)*40, 200 + Math.floor(i/3)*50, 'blue'));
}

function openShop() {
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('shop-menu').style.display = 'flex';
    renderShop();
}

function closeShop() {
    document.getElementById('shop-menu').style.display = 'none';
    document.getElementById('main-menu').style.display = 'flex';
}

function renderShop() {
    const cont = document.getElementById('skin-container');
    cont.innerHTML = '';
    Object.keys(SKINS).forEach(key => {
        let skin = SKINS[key];
        let div = document.createElement('div');
        div.className = `skin-card ${currentSkin === key ? 'active' : ''}`;
        div.innerHTML = `
            <div class="skin-preview" style="background:${skin.ally}"></div>
            <div style="font-weight:bold; color:white;">${skin.name}</div>
        `;
        div.onclick = () => { currentSkin = key; renderShop(); };
        cont.appendChild(div);
    });
}

// -- INPUTS --
let mouseX=0, mouseY=0;
canvas.addEventListener('mousemove', e => { mouseX=e.clientX; mouseY=e.clientY; if(isDragging) dragCurrent={x:mouseX,y:mouseY}; });
canvas.addEventListener('mousedown', e => {
    if(gameState !== 'PLAY') return;
    if(e.button!==0) return;
    isDragging=true; dragStart={x:e.clientX,y:e.clientY}; dragCurrent={x:e.clientX,y:e.clientY};
});
canvas.addEventListener('mouseup', e => {
    if(gameState !== 'PLAY') return;
    if(!isDragging) return;
    isDragging=false;
    let dist = Math.hypot(dragCurrent.x-dragStart.x, dragCurrent.y-dragStart.y);
    if(dist < 10) {
        let clicked = null;
        for(let u of army) if(Math.hypot(u.x-mouseX, u.y-mouseY) < u.size+15) { clicked=u; break; }
        selectedUnits = clicked ? [clicked] : [];
    } else {
        let x=Math.min(dragStart.x, dragCurrent.x), y=Math.min(dragStart.y, dragCurrent.y);
        let w=Math.abs(dragCurrent.x-dragStart.x), h=Math.abs(dragCurrent.y-dragStart.y);
        selectedUnits = army.filter(u => u.x>x && u.x<x+w && u.y>y && u.y<y+h);
    }
    updateInspector();
});

// -- CREATURE CLASS --
class Creature {
    constructor(x, y, team, mutations=[], isBoss=false) {
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.team = team;
        this.mutations = [...mutations];
        this.isBoss = isBoss;
        
        this.maxHp = isBoss ? 5000 + (difficulty*1000) : 100 + (difficulty*10);
        this.size = isBoss ? 40 : 14;
        this.accel = isBoss ? 0.15 : 0.3;
        
        if(!isBoss) this.maxHp += 50 * this.mutations.length;
        this.hp = this.maxHp;
        
        this.friction = 0.94;
        this.waddleOffset = Math.random()*100;
        this.cooldowns = {};
        this.invisible = false; // For Ghost
    }

    update() {
        this.vx *= this.friction; this.vy *= this.friction;
        
        // Boundaries
        if(this.x<50) this.vx+=0.5; if(this.x>canvas.width-50) this.vx-=0.5;
        if(this.y<50) this.vy+=0.5; if(this.y>canvas.height-50) this.vy-=0.5;

        // Boss Minions
        if(this.isBoss && frame % 120 === 0) {
            let type = STD_KEYS[Math.floor(Math.random()*STD_KEYS.length)];
            let m = new Creature(this.x, this.y, 'red', [type]);
            m.vx = (Math.random()-0.5)*10; m.vy = (Math.random()-0.5)*10;
            enemies.push(m);
        }

        // Passives
        if(this.mutations.includes('GRAVITY')) {
            let pool = this.team==='blue' ? enemies : army;
            pool.forEach(e => {
                if(Math.hypot(e.x-this.x, e.y-this.y) < 200) { e.vx *= 0.8; e.vy *= 0.8; }
            });
        }
        
        if(this.mutations.includes('GHOST')) {
            if(!this.cooldowns['GHOST_STATE']) {
                this.invisible = !this.invisible;
                this.cooldowns['GHOST_STATE'] = this.invisible ? 120 : 180;
                createParticles(this.x, this.y, "white", 5);
            } else {
                this.cooldowns['GHOST_STATE']--;
            }
        }

        let target = this.findTarget();
        if(target) {
            let dx = target.x - this.x, dy = target.y - this.y;
            let dist = Math.hypot(dx, dy);
            let angle = Math.atan2(dy, dx);
            this.angle = angle;
            
            let isRanged = this.mutations.some(m => MUTATIONS[m]?.type === 'range' || ['OMNI','GIGA_LASER'].includes(m));
            let optimal = isRanged ? (this.isBoss ? 400 : 250) : 0;

            if(dist > optimal) {
                this.vx += Math.cos(angle)*this.accel;
                this.vy += Math.sin(angle)*this.accel;
            } else if(isRanged && dist < optimal - 50) {
                this.vx -= Math.cos(angle)*(this.accel*0.8);
                this.vy -= Math.sin(angle)*(this.accel*0.8);
            }

            this.mutations.forEach((m, i) => {
                let cd = this.cooldowns['m'+i]||0;
                if(cd<=0 && (!this.invisible || m === 'GHOST')) this.useAbility(m, target, dist, 'm'+i);
                else this.cooldowns['m'+i]--;
            });

            if(dist < this.size + target.size && !this.invisible) {
                let dmg = this.isBoss ? 20 : 2;
                if(this.mutations.includes('SPIKES')) dmg+=10;
                if(this.mutations.includes('BERSERK')) {
                    let missingPct = 1 - (this.hp/this.maxHp);
                    dmg += (missingPct * 15); // Up to +15 dmg
                }
                if(this.mutations.includes('VAMP')) { this.hp = Math.min(this.hp+5, this.maxHp); dmg+=5; }
                target.takeDamage(dmg);
                let push = 4;
                this.vx = -Math.cos(angle)*push; this.vy = -Math.sin(angle)*push;
            }
        }
        
        this.x += this.vx; this.y += this.vy;
    }

    findTarget() {
        let pool = this.team==='blue' ? enemies : army;
        let best=null, min=9999;
        for(let e of pool) { 
            // Ghost logic: Ignore invisible enemies unless extremely close
            if(e.invisible && Math.hypot(e.x-this.x, e.y-this.y) > 50) continue;
            let d=Math.hypot(e.x-this.x, e.y-this.y); 
            if(d<min){min=d; best=e;} 
        }
        return best;
    }

    useAbility(key, target, dist, cdKey) {
        // ULTRA
        if(key === 'BLACK_HOLE' && dist < 400) {
            ctx.beginPath(); ctx.arc(this.x,this.y, 400, 0, 6.28); ctx.strokeStyle="purple"; ctx.stroke();
            let pool = this.team==='blue' ? window.enemies : window.army;
            pool.forEach(e => {
                if(Math.hypot(e.x-this.x, e.y-this.y) < 400) {
                    let a = Math.atan2(this.y-e.y, this.x-e.x);
                    e.vx += Math.cos(a)*1.5; e.vy += Math.sin(a)*1.5;
                    e.takeDamage(0.5);
                }
            });
            this.cooldowns[cdKey] = 5;
        }
        if(key === 'METEOR' && dist < 600) {
            for(let i=0; i<3; i++) {
                let tx = target.x + (Math.random()-0.5)*100;
                let ty = target.y + (Math.random()-0.5)*100;
                projectiles.push(new Projectile(this, {x:tx, y:ty}, 'METEOR'));
            }
            this.cooldowns[cdKey] = 60;
        }
        if(key === 'GIGA_LASER' && dist < 600) {
            ctx.save(); ctx.lineWidth=15; ctx.strokeStyle="magenta"; ctx.shadowBlur=20; ctx.shadowColor="purple";
            ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(target.x,target.y); ctx.stroke(); ctx.restore();
            target.takeDamage(15); this.cooldowns[cdKey] = 10;
        }

        // STANDARD
        if(key === 'LASER' && dist < 350) { spawnProj(this, target, 'LASER'); this.cooldowns[cdKey] = 40; }
        if(key === 'RICOCHET' && dist < 400) { spawnProj(this, target, 'RICOCHET'); this.cooldowns[cdKey] = 50; }
        if(key === 'BEAM' && dist < 500) {
            ctx.save(); ctx.strokeStyle = "#00ccff"; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor="cyan";
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(target.x, target.y); ctx.stroke(); ctx.restore();
            target.takeDamage(2); this.cooldowns[cdKey] = 3;
        }
        if(key === 'SHOTGUN' && dist < 200) { for(let i=-0.3; i<=0.3; i+=0.3) spawnProj(this, target, 'SHOTGUN', i); this.cooldowns[cdKey] = 60; }
        if(key === 'HEALER') { 
            (this.team==='blue'?army:enemies).forEach(m => { if(Math.hypot(m.x-this.x,m.y-this.y)<100) m.hp=Math.min(m.hp+0.5, m.maxHp); }); 
        }
    }

    takeDamage(n) {
        if(this.invisible) return; // Ghost phase immunity or just harder to hit? Let's say partial immunity
        if(this.mutations.includes('DIVINE')) n *= 0.2; 
        if(this.mutations.includes('SHIELD') && Math.random()<0.3) { createParticles(this.x, this.y, "cyan", 2); return; }
        this.hp -= n;
        if(this.hp <= 0) {
            if(this.mutations.includes('NOVA')) {
                // Frost Nova Effect
                createExplosion(this.x, this.y, 100, "rgba(0,200,255,0.5)");
                let pool = this.team==='blue' ? enemies : army;
                pool.forEach(e => {
                    if(Math.hypot(e.x-this.x, e.y-this.y) < 100) { e.vx=0; e.vy=0; e.takeDamage(10); }
                });
            }
            if(this.isBoss) spawnDNA(this.x, this.y, ULTRA_KEYS[Math.floor(Math.random()*ULTRA_KEYS.length)], true);
        }
    }

    draw() {
        if(this.invisible) ctx.globalAlpha = 0.3;
        
        let stretch = Math.min(Math.hypot(this.vx, this.vy)*0.05, 0.4);
        ctx.save(); ctx.translate(this.x, this.y);
        
        // MEDIC VISUAL
        if(this.mutations.includes('HEALER')) {
            ctx.save();
            ctx.rotate(frame * 0.05);
            ctx.strokeStyle = "#00ffaa"; ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -this.size-10); ctx.lineTo(0, -this.size-20);
            ctx.moveTo(-5, -this.size-15); ctx.lineTo(5, -this.size-15);
            ctx.stroke();
            
            // Spinning Circle Aura
            ctx.beginPath(); ctx.arc(0,0, this.size+15, 0, Math.PI*2);
            ctx.strokeStyle = "rgba(0, 255, 170, 0.3)"; ctx.lineWidth = 2; ctx.stroke();
            ctx.restore();
        }
        
        // Selection Ring
        if(selectedUnits.includes(this)) {
            ctx.beginPath(); ctx.arc(0, 0, this.size+10, 0, 6.28);
            ctx.strokeStyle = "#00ffaa"; ctx.lineWidth=2; ctx.stroke();
        }

        ctx.rotate(this.angle); ctx.scale(1+stretch, 1-stretch); ctx.rotate(-this.angle);

        // Body Color Logic
        let bodyColor;
        if(this.isBoss) bodyColor = '#550000';
        else if(this.team === 'blue') bodyColor = SKINS[currentSkin].ally;
        else bodyColor = SKINS[currentSkin].enemy; // Inverse Skin

        if(this.mutations.includes('NUKE')) bodyColor = "#33ff33";
        
        ctx.fillStyle = bodyColor;
        ctx.beginPath(); ctx.ellipse(0, 0, this.size*1.2, this.size, 0, 0, 6.28); ctx.fill();
        
        // Belly
        ctx.fillStyle="white"; ctx.beginPath(); ctx.ellipse(2, 0, this.size*0.9, this.size*0.7, 0, 0, 6.28); ctx.fill();
        
        // Face
        ctx.fillStyle="black"; ctx.beginPath(); ctx.arc(6, -4, 2, 0, 6.28); ctx.arc(6, 4, 2, 0, 6.28); ctx.fill();
        ctx.fillStyle="#ffaa00"; ctx.beginPath(); ctx.moveTo(10,-2); ctx.lineTo(18,0); ctx.lineTo(10,2); ctx.fill();

        // Mutations
        this.mutations.forEach(m => {
            if(ULTRA_MUTATIONS[m]) {
                ctx.fillStyle = ULTRA_MUTATIONS[m].color;
                ctx.beginPath(); ctx.arc(0, -this.size-5, 5, 0, 6.28); ctx.fill();
            } else {
                drawStandardMutation(ctx, m, this.size);
            }
        });

        // Boss Crown
        if(this.isBoss) {
            ctx.fillStyle = "gold";
            ctx.beginPath(); ctx.moveTo(-10, -15); ctx.lineTo(-5, -25); ctx.lineTo(0, -15); ctx.lineTo(5, -25); ctx.lineTo(10, -15); ctx.fill();
        }

        // HP
        ctx.rotate(-this.angle); ctx.scale(1/(1+stretch), 1/(1-stretch));
        ctx.fillStyle="rgba(0,0,0,0.5)"; ctx.fillRect(-15, -this.size-15, 30, 4);
        ctx.fillStyle=this.hp/this.maxHp>0.5 ? "#00ff00":"#ff0000"; ctx.fillRect(-14, -this.size-14.5, 28*(this.hp/this.maxHp), 3);
        ctx.restore();
        
        ctx.globalAlpha = 1.0;
    }
}

// -- PROJECTILES --
class Projectile {
    constructor(owner, target, type, angleOff=0) {
        this.x = owner.x; this.y = owner.y; this.type = type; this.owner = owner;
        this.target = target; // For Ricochet
        let a = Math.atan2(target.y-owner.y, target.x-owner.x)+angleOff;
        this.vx=Math.cos(a); this.vy=Math.sin(a);
        
        if(type==='METEOR') {
            this.x = target.x; this.y = target.y - 500; this.targetY = target.y;
            this.vx = 0; this.vy = 15; this.life = 100;
        } else {
            let s = {LASER:10, RICOCHET: 8, SNIPER:20, SHOTGUN:8, FLAME:5, MISSILE:4}[type] || 10;
            this.vx*=s; this.vy*=s; this.life = 60;
            if(type==='MISSILE') this.life=100;
        }
        this.hasBounced = false; // Ricochet State
    }
    update() {
        this.x+=this.vx; this.y+=this.vy; this.life--;
        if(this.type==='METEOR') {
            if(this.y >= this.targetY) {
                createExplosion(this.x, this.y, 60, "orange");
                let pool = this.owner.team==='blue'?enemies:army;
                pool.forEach(t => { if(Math.hypot(t.x-this.x, t.y-this.y)<60) t.takeDamage(50); });
                this.life=0;
            }
            return;
        }

        let pool = this.owner.team==='blue'?enemies:army;
        for(let t of pool) {
            if(Math.hypot(t.x-this.x, t.y-this.y) < t.size+15) {
                let dmg = 10;
                if(this.type==='SNIPER') dmg=40;
                if(this.type==='MISSILE') { dmg=30; createExplosion(this.x,this.y,40,"orange"); }
                
                t.takeDamage(dmg);
                
                // RICOCHET LOGIC
                if(this.type === 'RICOCHET' && !this.hasBounced) {
                    this.hasBounced = true;
                    // Find new target
                    let best=null, min=300;
                    for(let nextT of pool) {
                        if(nextT === t) continue;
                        let d = Math.hypot(nextT.x - this.x, nextT.y - this.y);
                        if(d < min) { min = d; best = nextT; }
                    }
                    if(best) {
                        this.life = 30;
                        let a = Math.atan2(best.y-this.y, best.x-this.x);
                        this.vx = Math.cos(a)*8; this.vy = Math.sin(a)*8;
                        return; // Continue flying
                    }
                }
                
                this.life=0; break;
            }
        }
    }
    draw() {
        if(this.type==='METEOR') { ctx.fillStyle="orange"; ctx.beginPath(); ctx.arc(this.x, this.y, 10, 0, 6.28); ctx.fill(); }
        else if(this.type==='RICOCHET') { ctx.fillStyle="#8800ff"; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, 6.28); ctx.fill(); }
        else { ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, 6.28); ctx.fill(); }
    }
}

// -- SYSTEMS --
function spawnDNA(x, y, type, isUltra=false) { items.push({x, y, type, life: 2000, isUltra}); }
function spawnProj(o, t, type, off=0) { projectiles.push(new Projectile(o, t, type, off)); }
function drawLightning(x1,y1,x2,y2) { ctx.strokeStyle="yellow"; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo((x1+x2)/2, (y1+y2)/2); ctx.lineTo(x2,y2); ctx.stroke(); }
function createExplosion(x,y,r,c) { ctx.fillStyle=c; ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(x,y,r,0,6.28); ctx.fill(); ctx.globalAlpha=1; }
function createParticles(x,y,c,n) { for(let i=0; i<n; i++) particles.push({x,y,vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5,c,life:20}); }

// -- RENDERING HELPERS --
function drawStandardMutation(ctx, key, size) {
    if(key === 'SPIKES') { ctx.fillStyle = "#555"; for(let i=0; i<6; i++) { ctx.rotate(1); ctx.beginPath(); ctx.moveTo(size, -3); ctx.lineTo(size+8, 0); ctx.lineTo(size, 3); ctx.fill(); } }
    if(key === 'SHIELD') { ctx.strokeStyle = "cyan"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0,0, size+8, 0, 6.28); ctx.stroke(); }
    if(key === 'LASER') { ctx.fillStyle = "#333"; ctx.fillRect(-5, -18, 15, 6); ctx.fillStyle="red"; ctx.fillRect(10, -17, 2, 4); }
    if(key === 'BERSERK') { ctx.fillStyle = "red"; ctx.beginPath(); ctx.moveTo(-5,-15); ctx.lineTo(0,-25); ctx.lineTo(5,-15); ctx.fill(); }
    if(key === 'GHOST') { ctx.fillStyle = "white"; ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(0,-18, 4, 0, 6.28); ctx.fill(); ctx.globalAlpha=1;}
}

function drawVial(it) {
    let x = it.x, y = it.y;
    let isUltra = it.isUltra;
    let color = isUltra ? ULTRA_MUTATIONS[it.type].color : MUTATIONS[it.type].color;
    ctx.shadowBlur = 20; 
    ctx.shadowColor = isUltra ? "gold" : "white";
    ctx.fillStyle = isUltra ? "rgba(255, 200, 0, 0.4)" : "rgba(255, 255, 255, 0.3)";
    ctx.beginPath(); ctx.arc(x, y, 15, 0, 6.28); ctx.fill();
    ctx.shadowBlur = 0;
    let s = 1 + Math.sin(frame*0.1)*0.1;
    ctx.save(); ctx.translate(x, y); ctx.scale(s, s);
    ctx.strokeStyle = "white"; ctx.lineWidth=2; ctx.fillStyle="rgba(0,0,0,0.5)";
    ctx.beginPath(); ctx.roundRect(-5, -10, 10, 20, 3); ctx.fill(); ctx.stroke();
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.roundRect(-4, -5, 8, 14, 2); ctx.fill();
    if(isUltra) { ctx.fillStyle="gold"; ctx.font="bold 10px Arial"; ctx.fillText("★", -3, 5); }
    ctx.restore();
}

// -- UI UPDATES --
function renderInventory() {
    const stdDiv = document.getElementById('dna-inventory'); 
    const ultraDiv = document.getElementById('ultra-inventory');
    stdDiv.innerHTML = ""; ultraDiv.innerHTML = "";
    
    STD_KEYS.forEach(k => {
        if(inventory[k]>0) {
            let el = document.createElement('div');
            el.className = "dna-item" + (selectedDNA===k?" selected":"");
            el.innerHTML = `<span style="color:${MUTATIONS[k].color}">${MUTATIONS[k].name}</span> <span>x${inventory[k]}</span>`;
            el.onclick = () => { selectedDNA=k; renderInventory(); updateInspector(); };
            stdDiv.appendChild(el);
        }
    });

    ULTRA_KEYS.forEach(k => {
        if(inventory[k]>0) {
            let el = document.createElement('div');
            el.className = "dna-item ultra" + (selectedDNA===k?" selected":"");
            el.innerHTML = `<div style="color:${ULTRA_MUTATIONS[k].color}; font-weight:bold;">${ULTRA_MUTATIONS[k].name}</div><div style="font-size:10px; color:#aaa">${ULTRA_MUTATIONS[k].desc}</div>`;
            el.onclick = () => { selectedDNA=k; renderInventory(); updateInspector(); };
            ultraDiv.appendChild(el);
        }
    });
}

function updateInspector() {
    let p = document.getElementById('unit-inspector');
    let container = document.getElementById('slot-container');
    let multiInfo = document.getElementById('multi-select-info');
    let btn = document.getElementById('btnInject');
    
    if(selectedUnits.length === 0) { p.style.display = 'none'; return; }
    p.style.display = 'flex'; container.innerHTML = "";

    let validUnits = selectedUnits.filter(u => u.mutations.length < 5);

    if(selectedUnits.length === 1) {
        document.getElementById('inspector-title').innerText = "Unit Details";
        multiInfo.style.display = 'none';
        container.style.display = 'grid';
        
        let u = selectedUnits[0];
        for(let i=0; i<5; i++) {
            let s = document.createElement('div');
            let m = u.mutations[i];
            if(m) {
                let isU = !!ULTRA_MUTATIONS[m];
                s.className = isU ? "slot ultra-filled" : "slot filled";
                s.style.color = isU ? ULTRA_MUTATIONS[m].color : MUTATIONS[m].color;
                s.innerText = isU ? ULTRA_MUTATIONS[m].name : MUTATIONS[m].name;
            } else {
                s.className = "slot"; s.innerText = "Empty";
            }
            container.appendChild(s);
        }
    } else {
        document.getElementById('inspector-title').innerText = `Selection: ${selectedUnits.length}`;
        container.style.display = 'none';
        multiInfo.style.display = 'block';
        multiInfo.innerText = validUnits.length < selectedUnits.length ? `${selectedUnits.length - validUnits.length} full. ${validUnits.length} ready.` : "All units ready.";
    }

    if(selectedDNA && biomass >= 50) {
        btn.disabled = validUnits.length === 0;
        let count = validUnits.length;
        if(count === 0) btn.innerText = "No Space Available";
        else btn.innerText = selectedUnits.length > 1 ? `MASS INJECT (${count})` : "INJECT (50 Bio)";
    } else {
        btn.disabled = true;
        btn.innerText = selectedDNA ? "Need 50 Bio" : "Select DNA";
    }
}

function injectMutation() {
    if(!selectedDNA || biomass < 50) return;
    let validUnits = selectedUnits.filter(u => u.mutations.length < 5);
    validUnits.forEach(u => {
        if(biomass >= 50 && inventory[selectedDNA] > 0) {
            biomass -= 50; inventory[selectedDNA]--;
            u.mutations.push(selectedDNA); u.maxHp += 50; u.hp += 50;
            createParticles(u.x, u.y, "#00ffaa", 20);
        }
    });
    if(inventory[selectedDNA] <= 0) selectedDNA = null;
    renderInventory();
    updateInspector();
}

// -- MAIN LOOP --
function loop() {
    if(gameState !== 'PLAY') {
        if(gameState === 'OVER') {
            document.getElementById('game-over-menu').style.display = 'flex';
        }
        requestAnimationFrame(loop);
        return;
    }

    frame++;
    ctx.clearRect(0,0,canvas.width,canvas.height); 
    drawBackground();

    // Difficulty & Time
    let seconds = Math.floor(frame/60);
    if(frame % 3600 === 0) difficulty++; 
    if(frame % 60 === 0) biomass += 10;

    let timeStr = `${Math.floor(seconds/60)}:${(seconds%60).toString().padStart(2,'0')}`;
    document.getElementById('time-disp').innerText = timeStr;
    document.getElementById('diff-disp').innerText = difficulty;
    document.getElementById('bioDisplay').innerText = biomass;

    // Boss Spawn
    if(frame % 10800 === 10600) document.getElementById('boss-warning').style.display = "block";
    if(frame % 10800 === 0 && frame > 0) {
        document.getElementById('boss-warning').style.display = "none";
        let boss = new Creature(canvas.width-100, canvas.height/2, 'red', ['OMNI', 'MISSILE'], true);
        enemies.push(boss);
    }

    // Enemy Spawn (HARDER START)
    let cap = 3 + (army.length) + (difficulty*2);
    if(enemies.length < cap && Math.random() < (0.005 * difficulty)) {
        let muts = [];
        // Even at Difficulty 1, 20% chance for a random mutation
        if(Math.random() < 0.2 + (difficulty*0.1)) {
            muts.push(STD_KEYS[Math.floor(Math.random()*STD_KEYS.length)]);
        }
        enemies.push(new Creature(canvas.width, Math.random()*canvas.height, 'red', muts));
    }

    // Entities Update
    [...army, ...enemies, ...minions].forEach(c => { c.update(); c.draw(); });
    for(let i=army.length-1; i>=0; i--) if(army[i].hp<=0) { army.splice(i,1); updateInspector(); }
    for(let i=minions.length-1; i>=0; i--) { minions[i].update(); minions[i].draw(); minions[i].life--; if(minions[i].life<=0 || minions[i].hp<=0) minions.splice(i,1); }
    
    for(let i=enemies.length-1; i>=0; i--) {
        if(enemies[i].hp<=0) {
            let e = enemies[i];
            if(e.mutations.length>0 && Math.random()<0.2) spawnDNA(e.x, e.y, e.mutations[0]); 
            if(!e.isBoss) {
                e.team = 'blue'; e.hp = e.maxHp*0.5; e.mutations=[]; 
                army.push(e); 
            }
            createParticles(e.x, e.y, "pink", 15);
            enemies.splice(i,1);
        }
    }

    for(let i=items.length-1; i>=0; i--) {
        let it = items[i]; it.life--; drawVial(it);
        if(Math.hypot(mouseX-it.x, mouseY-it.y) < 35) { inventory[it.type]++; renderInventory(); biomass+=10; items.splice(i,1); }
        else if(it.life<=0) items.splice(i,1);
    }
    
    for(let i=projectiles.length-1; i>=0; i--) { projectiles[i].update(); projectiles[i].draw(); if(projectiles[i].life<=0) projectiles.splice(i,1); }
    for(let i=particles.length-1; i>=0; i--) { let p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,3,3); if(p.life<=0) particles.splice(i,1); }

    if(isDragging) {
        let w = dragCurrent.x - dragStart.x; let h = dragCurrent.y - dragStart.y;
        ctx.strokeStyle = "#00ffaa"; ctx.setLineDash([5, 5]); ctx.strokeRect(dragStart.x, dragStart.y, w, h); ctx.setLineDash([]);
    }

    if(army.length === 0) gameState = 'OVER';
    
    requestAnimationFrame(loop);
}

renderInventory();
showMainMenu(); // Initialize at Menu
loop();
</script>
</body>
</html>
