<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Penguin Evolution: Visuals & Shortcuts</title>
    <style>
        body { margin: 0; background: #000; color: #004466; font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        
        canvas { display: block; cursor: crosshair; }
        
        /* UI PANEL */
        #lab-panel {
            position: absolute; right: 0; top: 0; bottom: 0; width: 300px;
            background: linear-gradient(to bottom, #0a1520, #020508); 
            border-left: 4px solid #55aaff;
            padding: 15px; display: flex; flex-direction: column;
            color: white; box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5); z-index: 10;
        }

        h2 { color: #55aaff; margin: 10px 0 5px 0; font-size: 14px; text-transform: uppercase; border-bottom: 1px solid #335577; padding-bottom: 5px; }
        .inventory-section { flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 4px; max-height: 25%; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #335577; border-radius: 3px; }

        .dna-item {
            background: #253545; padding: 6px 10px; border-radius: 4px; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #334455; transition: 0.1s; font-size: 12px; position: relative;
        }
        .dna-item:hover { background: #304050; border-color: #55aaff; }
        .dna-item.selected { border: 2px solid #00ffaa; background: #1a3a4a; }
        .dna-item.ultra { border: 1px solid #aa6600; background: #2a1a00; }
        
        /* Shortcuts Hint */
        .shortcut-hint { font-size: 10px; color: #888; margin-top: 5px; text-align: center; }

        button {
            background: #55aaff; color: #002233; border: none; padding: 10px;
            font-weight: bold; cursor: pointer; border-radius: 6px; width: 100%;
            text-transform: uppercase; transition: 0.2s; font-size: 12px;
        }
        button:hover { background: #88ccff; box-shadow: 0 0 15px #55aaff; }

        /* INSPECTOR PANEL */
        #inspector-panel {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-65%);
            width: 400px; background: rgba(5, 15, 25, 0.9); border: 2px solid #55aaff; border-radius: 10px;
            padding: 15px; display: none; flex-direction: column; align-items: center;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.3); color: white; z-index: 20;
        }
        #insp-name { font-size: 18px; font-weight: bold; color: #00ffaa; margin-bottom: 5px; }
        #insp-gen { font-size: 12px; color: #88ccff; margin-bottom: 5px; font-style: italic; }
        #insp-hp-bar { width: 100%; height: 6px; background: #333; margin-bottom: 10px; position: relative; }
        #insp-hp-fill { height: 100%; background: #00ffaa; width: 50%; transition: 0.2s; }
        .slot-container { display: flex; gap: 10px; justify-content: center; }
        .slot {
            width: 50px; height: 50px; background: #112233; border: 1px solid #334455;
            display: flex; align-items: center; justify-content: center; font-size: 10px;
            text-align: center; color: #556677; border-radius: 5px; position: relative;
        }
        .slot.filled { border-color: #00ffaa; color: white; background: #1a3a4a; font-weight: bold; }
        .slot.empty { border-style: dashed; }

        /* MENUS */
        .overlay-menu {
            position: absolute; top: 0; left: 0; right: 300px; bottom: 0;
            background: rgba(0, 15, 30, 0.95); display: flex; align-items: center; justify-content: center; flex-direction: column; z-index: 50;
        }
        .title-text { font-size: 60px; color: #fff; font-weight: 900; text-shadow: 0 0 30px #00aaff; margin-bottom: 10px; font-style: italic; }
        .menu-btn {
            background: linear-gradient(45deg, #0088ff, #00ffaa); color: #002233; width: 300px;
            font-size: 20px; padding: 15px; border: none; border-radius: 5px; margin-top: 20px;
            cursor: pointer; font-weight: bold; box-shadow: 0 0 30px rgba(0, 200, 255, 0.4);
        }
        .menu-btn.red { background: linear-gradient(45deg, #ff4400, #ff8800); box-shadow: 0 0 30px rgba(255, 50, 0, 0.4); }
        
        /* SHOWCASE & SKINS */
        .modal {
            position: absolute; top: 50px; bottom: 50px; left: 100px; right: 400px;
            background: #05101a; border: 2px solid #55aaff; border-radius: 10px;
            z-index: 60; display: none; flex-direction: row; overflow: hidden;
        }
        #showcase-list, #skins-list { width: 250px; background: #020508; overflow-y: auto; padding: 10px; border-right: 1px solid #335577; }
        #showcase-preview, #skins-preview { flex-grow: 1; position: relative; background: radial-gradient(circle, #1a2a3a, #000); }
        .sc-btn { width: 100%; padding: 10px; margin-bottom: 5px; background: #112233; color: white; border: 1px solid #334455; cursor: pointer; text-align: left; transition:0.2s; }
        .sc-btn:hover { background: #223344; color: #55aaff; }
        .sc-btn.active { border-left: 4px solid #00ffaa; background: #1a2a3a; color:#00ffaa; }
        
        /* CLOSE BUTTON FOR MODALS */
        .close-modal-btn {
            position: absolute; top: 20px; right: 20px;
            background: #ff4444; color: white; border: none; padding: 10px 20px;
            font-weight: bold; cursor: pointer; border-radius: 5px; width: auto;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        .close-modal-btn:hover { background: #ff6666; }

        #game-over { display: none; }
        #exit-btn { position: absolute; top: 10px; right: 320px; z-index: 40; background: rgba(255, 50, 50, 0.8); color: white; width: auto; padding: 8px 15px; }
        #info-overlay { position: absolute; top: 10px; left: 10px; pointer-events: none; color: #fff; font-weight: bold; text-shadow: 0 0 5px #000; }
        #boss-warning { position: absolute; top: 100px; left: 50%; transform: translateX(-65%); font-size: 40px; color: red; font-weight: bold; text-shadow: 0 0 20px red; display:none; pointer-events: none;}
        
        #sc-desc {
            position: absolute; bottom: 20px; left: 20px; right: 20px;
            color: #00ffaa; font-family: monospace; font-size: 16px;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 5px;
            border: 1px solid #00ffaa; box-shadow: 0 0 10px #005544;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="info-overlay">Threat Lvl: <span id="diff-disp">1</span> | Penguins: <span id="pop-disp">9</span></div>
    <div id="boss-warning">⚠️ BOSS APPROACHING ⚠️</div>

    <div id="start-menu" class="overlay-menu">
        <div class="title-text">FROZEN ARMORY</div>
        <button class="menu-btn" onclick="startGame()">DEPLOY COLONY</button>
        <button class="menu-btn" onclick="openSkins()" style="background: linear-gradient(45deg, #ffcc00, #ffee00);">SKINS</button>
        <button class="menu-btn" onclick="openShowcase()" style="background: linear-gradient(45deg, #aa00ff, #55aaff);">MUTATION GALLERY</button>
    </div>

    <div id="game-over" class="overlay-menu" style="background: rgba(50, 0, 0, 0.9);">
        <div class="title-text" style="color:#ff4444; text-shadow:0 0 30px red;">EXTINCTION</div>
        <button class="menu-btn red" onclick="retryGame()">RE-EVOLVE</button>
        <button class="menu-btn" onclick="goToMenu()" style="background:#444; color:white;">RETURN TO MENU</button>
    </div>

    <div id="inspector-panel">
        <div id="insp-name">UNIT SCAN: PENGUIN-01</div>
        <div id="insp-gen">Generation 0</div>
        <div id="insp-hp-bar"><div id="insp-hp-fill"></div></div>
        <div class="slot-container" id="insp-slots"></div>
    </div>

    <div id="showcase-modal" class="modal">
        <div id="showcase-list">
            <div style="display:flex; margin-bottom:10px;">
                <div class="tab active" onclick="loadShowcaseTabs('std')" style="flex:1; padding:5px; background:#55aaff; color:black; text-align:center; cursor:pointer;">STANDARD</div>
                <div class="tab" onclick="loadShowcaseTabs('ultra')" style="flex:1; padding:5px; background:#333; color:#aaa; text-align:center; cursor:pointer;">ULTRA</div>
            </div>
            <div id="sc-items"></div>
            <button onclick="clearShowcase()" style="margin-top:10px; background:#aa4400; font-size:10px; padding:5px;">Clear All</button>
        </div>
        <div id="showcase-preview">
            <button class="close-modal-btn" onclick="closeModal('showcase-modal')">EXIT GALLERY</button>
            <canvas id="scCanvas"></canvas>
            <div id="sc-desc">Hover over a mutation to see details...</div>
        </div>
    </div>

    <div id="skins-modal" class="modal">
        <div id="skins-list">
            <h3 style="color:white; text-align:center; margin-top:0;">SELECT SKIN</h3>
            <div id="skin-buttons"></div>
            <button onclick="closeModal('skins-modal')" style="margin-top:20px; background:#444;">Close</button>
        </div>
        <div id="skins-preview">
            <canvas id="skinCanvas"></canvas>
            <div style="position:absolute; bottom:20px; left:20px; color:white; font-family:monospace; background:rgba(0,0,0,0.7); padding:10px; border-radius:5px;">Previewing Skin...</div>
        </div>
    </div>

    <button id="exit-btn" onclick="goToMenu()" style="display:none;">EXIT</button>

    <div id="lab-panel">
        <h2 style="margin-top:0">Biomass: <span id="bioDisplay" style="color:#00ffaa">1000</span></h2>
        <h2>Standard DNA</h2>
        <div id="dna-inventory" class="inventory-section"></div>
        <h2 style="color:#ffaa00">Ultra Vault</h2>
        <div id="ultra-inventory" class="inventory-section"></div>
        
        <div class="shortcut-hint">[E] Cycle DNA | [Q] Inject</div>

        <div style="margin-top:auto; padding-top:10px; border-top:1px solid #333">
             <button id="btnInject" onclick="injectMutation()">Select Units</button>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
// --- CONFIG & DATA ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth - 300; canvas.height = window.innerHeight;

const SKINS = {
    CLASSIC: { name: 'Classic Ops' },
    NEON: { name: 'Neon Wireframe' },
    CAMO: { name: 'Arctic Camo' },
    GOLD: { name: 'Golden Midas' },
    UNDEAD: { name: 'Undead Horde' },
    MECHA: { name: 'Mecha Unit' }
};
let currentSkin = 'CLASSIC';

const MUTATIONS = {
    LASER: { name: 'Laser Eyes', color: '#ff0055', desc: 'Fires a high-velocity red beam that deals instant damage.' },
    SPIKES: { name: 'Spiked Armor', color: '#888888', desc: 'Reflects melee damage back to attackers and increases collision damage.' },
    HEALER: { name: 'Medic Aura', color: '#00ffaa', desc: 'Slowly regenerates the health of nearby allies.' },
    SHOTGUN: { name: 'Snow Blaster', color: '#ffffff', desc: 'Fires 3 spread shots at once for crowd control.' },
    SNIPER: { name: 'Icicle Sniper', color: '#00ff00', desc: 'Fires a long-range, high-damage projectile. Slow reload.' },
    MISSILE: { name: 'Fish Missile', color: '#ffaa00', desc: 'Launches a homing rocket that explodes on impact.' },
    SAW: { name: 'Buzz Saw', color: '#cccccc', desc: 'Melee unit. Shreds enemies on contact with high damage.' },
    SHIELD: { name: 'Bubble Shield', color: '#00ffff', desc: 'Provides a temporary energy barrier that absorbs damage.' },
    TESLA: { name: 'Shock Coil', color: '#ffff00', desc: 'Periodically zaps nearby enemies with chain lightning.' },
    FLAME: { name: 'Flamethrower', color: '#ff4400', desc: 'Spews fire that damages enemies over time.' },
    RICOCHET: { name: 'Ricochet', color: '#ff00ff', desc: 'Projectiles bounce off enemies to hit additional targets.' },
    POISON: { name: 'Toxic Gas', color: '#008800', desc: 'Releases a poison cloud that damages enemies standing in it.' },
    BERSERK: { name: 'Berserker', color: '#880000', desc: 'Significantly increases movement and attack speed.' },
    FROST: { name: 'Frost Nova', color: '#6699ff', desc: 'Periodically freezes nearby enemies, slowing them down.' },
    STEALTH: { name: 'Active Camo', color: '#444444', desc: 'Makes the unit nearly invisible until it attacks.' },
    
    // NEW MUTATIONS
    PLASMA: { name: 'Plasma Orb', color: '#00aaff', desc: 'Fires a slow-moving orb that continuously zaps enemies in range.' },
    BOOMERANG: { name: 'Boomerang', color: '#aa5500', desc: 'Throws a bone that passes through enemies and returns.' },
    TRAP: { name: 'Spike Trap', color: '#555555', desc: 'Deploys a bear trap on the ground. Snaps shut on enemies.' },
    VORTEX: { name: 'Grav Vortex', color: '#7700ff', desc: 'Creates a gravity well that pulls enemies toward the unit.' },
    GHOST: { name: 'Ghost Phase', color: '#aaddff', desc: 'Grants a chance to phase through attacks, taking 0 damage.' }
};

const ULTRA_MUTATIONS = {
    BLACK_HOLE: { name: 'Black Hole', color: '#220033', desc: 'ULTRA: Collapses space, instantly destroying weak enemies.' },
    METEOR: { name: 'Meteor Swarm', color: '#ff4400', desc: 'ULTRA: Calls down raining fireballs from the sky.' },
    NECRO: { name: 'Necromancy', color: '#00ff44', desc: 'ULTRA: Raises dead enemies as skeleton minions.' },
    OMNI: { name: 'Omni-Blaster', color: '#ffffff', desc: 'ULTRA: Fires in all directions simultaneously.' },
    TIME: { name: 'Time Freeze', color: '#0000ff', desc: 'ULTRA: Periodically freezes time for enemies.' },
    VAMP: { name: 'Vampirism', color: '#aa0000', desc: 'ULTRA: Heals for 50% of damage dealt.' },
    GIGA_LASER: { name: 'Orbital Cannon', color: '#ff00aa', desc: 'ULTRA: Fires a massive beam that pierces everything.' },
    THOR: { name: 'Thunder God', color: '#ffffaa', desc: 'ULTRA: Summons massive lightning strikes constantly.' },
    NUKE: { name: 'Nuclear Core', color: '#00ff00', desc: 'ULTRA: Explodes on death, wiping out the screen.' },
    DIVINE: { name: 'Divine Shield', color: '#ffd700', desc: 'ULTRA: Makes the unit invincible for short periods.' }
};

let gameState = 'MENU';
let army = [], enemies = [], items = [], projectiles = [], particles = [], texts = [], traps = [];
let inventory = {}, selectedUnits = [], selectedDNA = [];
let biomass = 1000, frame = 0, difficulty = 1;
let bossTimer = 0;
const BOSS_INTERVAL = 180 * 60; // 3 minutes at 60fps
let cycleIndex = 0; // For E key cycling

// --- VISUAL DRAWING FUNCTIONS ---

function drawDetailedMutation(ctx, key, size) {
    ctx.save();
    // NEW VISUALS UPDATE
    
    if(key === 'GHOST') {
        // Improved GHOST: Flickering Phantom Silhouette
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.4 + Math.sin(frame * 0.2) * 0.2;
        ctx.translate(0, -size/2);
        
        // Draw a "spirit" shape behind
        ctx.fillStyle = "#aaddff";
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.quadraticCurveTo(10, -5, 5, 10);
        ctx.quadraticCurveTo(0, 5, -5, 10);
        ctx.quadraticCurveTo(-10, -5, 0, -15);
        ctx.fill();
        
        // Ghost Eyes
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(-3, -5, 2, 0, 6.28); ctx.arc(3, -5, 2, 0, 6.28); ctx.fill();
        
        ctx.restore();
    }
    else if(key === 'TRAP') {
        // Improved TRAP: Bear Trap Backpack
        ctx.translate(0, 5);
        ctx.fillStyle = "#444";
        ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI, true); ctx.fill(); // Base
        
        ctx.strokeStyle = "#888"; ctx.lineWidth=2;
        // Jaws (open)
        ctx.beginPath(); 
        ctx.moveTo(-8, 0); ctx.lineTo(-6, -4); ctx.lineTo(-4, 0); ctx.lineTo(-2, -4); ctx.lineTo(0,0);
        ctx.lineTo(2, -4); ctx.lineTo(4, 0); ctx.lineTo(6, -4); ctx.lineTo(8, 0);
        ctx.stroke();
    }
    else if(key === 'PLASMA') {
        ctx.fillStyle = "rgba(0,180,255,0.4)"; ctx.beginPath(); ctx.arc(0, -size-5, 6, 0, 6.28); ctx.fill();
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(0, -size-5, 3, 0, 6.28); ctx.fill();
    }
    else if(key === 'BOOMERANG') {
        ctx.translate(10, 0); ctx.rotate(frame*0.1);
        ctx.fillStyle = "#8b4513"; ctx.beginPath(); ctx.moveTo(-2,-8); ctx.quadraticCurveTo(5,0,-2,8); ctx.lineTo(2,8); ctx.quadraticCurveTo(10,0,2,-8); ctx.fill();
    }
    else if(key === 'VORTEX') {
        ctx.strokeStyle = "#8000ff"; ctx.lineWidth=1; ctx.beginPath(); 
        let r = 10 + Math.sin(frame*0.2)*2;
        ctx.ellipse(0, 0, r, 4, frame*0.1, 0, 6.28); ctx.stroke();
    }

    // ULTRA
    else if(key === 'BLACK_HOLE') {
        ctx.fillStyle = "#000"; ctx.strokeStyle = "#a0a"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, -size-10, 8, 0, 6.28); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(0, -size-10, 14, 4, frame*0.1, 0, 6.28); ctx.strokeStyle="white"; ctx.stroke();
    }
    else if(key === 'METEOR') {
        for(let i=0; i<3; i++) {
            let angle = frame*0.05 + (i*2);
            let mx = Math.cos(angle)*(size+10), my = Math.sin(angle)*(size+10);
            ctx.fillStyle = "#664422"; ctx.beginPath(); ctx.arc(mx, my, 4, 0, 6.28); ctx.fill();
        }
    }
    else if(key === 'NECRO') {
        ctx.fillStyle = "#ddd"; ctx.beginPath(); ctx.arc(8, 0, 8, 0, 6.28); ctx.fill();
        ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(10, -2, 2, 0, 6.28); ctx.arc(10, 2, 2, 0, 6.28); ctx.fill();
        ctx.strokeStyle = "#0f0"; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, -20); ctx.stroke();
    }
    else if(key === 'OMNI') {
        ctx.fillStyle = "#888"; 
        for(let i=0; i<4; i++) { ctx.save(); ctx.rotate(i * (Math.PI/2) + frame*0.02); ctx.fillRect(size, -2, 8, 4); ctx.restore(); }
    }
    else if(key === 'TIME') {
        ctx.translate(0, -5); ctx.strokeStyle = "rgba(0, 100, 255, 0.8)"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(0, 0, 10, 0, 6.28); ctx.stroke();
        ctx.save(); ctx.rotate(frame*0.1); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, -8); ctx.stroke(); ctx.restore();
    }
    else if(key === 'VAMP') {
        ctx.fillStyle = "#aa0000"; 
        ctx.beginPath(); ctx.moveTo(5, -5); ctx.quadraticCurveTo(20, -20, 30, -5); ctx.lineTo(10, 5); ctx.fill();
        ctx.beginPath(); ctx.moveTo(5, 5); ctx.quadraticCurveTo(20, 20, 30, 5); ctx.lineTo(10, -5); ctx.fill();
    }
    else if(key === 'GIGA_LASER') {
        ctx.translate(0, -5); ctx.fillStyle = "#444"; ctx.fillRect(0, -6, 25, 12);
        ctx.fillStyle = "cyan"; ctx.shadowBlur=10; ctx.shadowColor="cyan"; ctx.fillRect(5, -2, 18, 4); ctx.shadowBlur=0;
    }
    else if(key === 'THOR') {
        ctx.translate(12, 5); ctx.rotate(-0.5);
        ctx.fillStyle = "#666"; ctx.fillRect(-4, -8, 8, 5); ctx.strokeStyle = "#420"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0, -3); ctx.lineTo(0, 5); ctx.stroke();
        if(Math.random()>0.8) { ctx.strokeStyle="yellow"; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(Math.random()*20-10, -20); ctx.stroke(); }
    }
    else if(key === 'NUKE') {
        ctx.translate(-5, -5); ctx.fillStyle = "#00cc00"; ctx.beginPath(); ctx.arc(0, 0, 8, 0, 6.28); ctx.fill();
        if(frame%20<10) { ctx.strokeStyle="lime"; ctx.beginPath(); ctx.arc(0,0,10,0,6.28); ctx.stroke(); }
    }
    else if(key === 'DIVINE') {
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; 
        ctx.beginPath(); ctx.moveTo(-5, -5); ctx.quadraticCurveTo(-20, -20, -30, 0); ctx.lineTo(-5, 5); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-5, 5); ctx.quadraticCurveTo(-20, 20, -30, 0); ctx.lineTo(-5, -5); ctx.fill();
        ctx.strokeStyle = "gold"; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(-5, 0, 4, 10, 0, 0, 6.28); ctx.stroke();
    }
    
    // STANDARD VISUALS
    else if(key === 'LASER') { ctx.fillStyle = "#333"; ctx.fillRect(-6, -6, 12, 4); ctx.fillStyle = "red"; ctx.shadowBlur = 10; ctx.shadowColor = "red"; ctx.fillRect(-5, -5, 10, 2); }
    else if(key === 'SAW') { ctx.translate(size/2, 0); ctx.rotate(frame * 0.5); ctx.fillStyle = "#8899aa"; ctx.beginPath(); for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.lineTo(8, 0); ctx.lineTo(4, 4); } ctx.fill(); ctx.fillStyle = "#ddd"; ctx.beginPath(); ctx.arc(0,0,3,0,6.28); ctx.fill(); }
    else if(key === 'SNIPER') { ctx.translate(5, 5); ctx.fillStyle = "#445566"; ctx.fillRect(0, -2, 8, 4); }
    else if(key === 'SHOTGUN') { ctx.translate(5, 5); ctx.fillStyle = "#553311"; ctx.fillRect(0, -2, 10, 4); }
    else if(key === 'FLAME') { ctx.translate(5, 5); ctx.fillStyle = "#222"; ctx.fillRect(0, -3, 15, 6); ctx.fillStyle = "orange"; ctx.beginPath(); ctx.arc(15, 0, 2, 0, 6.28); ctx.fill(); }
    else if(key === 'MISSILE') { ctx.translate(-5, -5); ctx.fillStyle = "#445544"; ctx.fillRect(0, -8, 12, 8); }
    else if(key === 'SPIKES') { ctx.fillStyle = "#aaaaaa"; for(let i=0; i<3; i++) { ctx.save(); ctx.rotate((i-1)*1); ctx.beginPath(); ctx.moveTo(size, -4); ctx.lineTo(size+8, 0); ctx.lineTo(size, 4); ctx.fill(); ctx.restore(); } }
    else if(key === 'HEALER') { ctx.translate(-8, 0); ctx.fillStyle = "#eeeeee"; ctx.fillRect(-6, -8, 8, 16); ctx.fillStyle = "#ff0000"; ctx.fillRect(-4, -5, 4, 10); ctx.fillRect(-7, -2, 10, 4); }
    else if(key === 'POISON') { ctx.translate(-8, 0); ctx.fillStyle = "#224422"; ctx.fillRect(-4, -8, 6, 16); }
    else if(key === 'TESLA') { ctx.translate(-5, -10); ctx.fillStyle = "#b87333"; ctx.fillRect(-2, -10, 4, 10); ctx.strokeStyle = "yellow"; if(Math.random() > 0.8) { ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(Math.random()*10-5, -15); ctx.stroke(); } }
    else if(key === 'SHIELD') { ctx.strokeStyle = "cyan"; ctx.lineWidth = 1; ctx.globalAlpha = 0.4; ctx.beginPath(); ctx.arc(0,0, size+5, 0, 6.28); ctx.stroke(); ctx.fillStyle = "rgba(0, 255, 255, 0.1)"; ctx.fill(); }
    else if(key === 'BERSERK') { ctx.strokeStyle = "red"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(2, -8); ctx.lineTo(6, -4); ctx.stroke(); ctx.beginPath(); ctx.moveTo(14, -8); ctx.lineTo(10, -4); ctx.stroke(); }
    else if(key === 'FROST') { ctx.rotate(frame*0.05); ctx.fillStyle = "cyan"; ctx.fillRect(size+5, 0, 4, 4); ctx.rotate(3.14); ctx.fillRect(size+5, 0, 4, 4); }
    else if(key === 'RICOCHET') { ctx.translate(5, 5); ctx.fillStyle = "magenta"; ctx.globalAlpha = 0.8; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(10,-5); ctx.lineTo(10,5); ctx.fill(); }
    else if(key === 'STEALTH') { ctx.fillStyle="#333"; ctx.globalAlpha=0.5; ctx.fillRect(-size, -size, size*2, size*2); }
    
    ctx.restore();
}

class DamageText {
    constructor(x, y, amount, color) {
        this.x = x + (Math.random()*20 - 10);
        this.y = y - 20;
        this.text = Math.floor(amount);
        this.color = color;
        this.life = 40; this.vy = -1;
    }
    update() { this.y += this.vy; this.life--; }
    draw(ctx) {
        ctx.fillStyle = this.color; ctx.font = "bold 14px Consolas";
        ctx.strokeStyle = "black"; ctx.lineWidth = 2;
        ctx.globalAlpha = this.life / 40;
        ctx.strokeText(this.text, this.x, this.y); ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
    }
}

class Trap {
    constructor(x, y, owner) {
        this.x = x; this.y = y; this.owner = owner; this.life = 600;
        this.triggered = false;
        this.closeAnim = 0; // 0 = open, 1 = closed
    }
    update() {
        if(this.triggered) {
            this.life-=20; // Disappear fast after triggering
            this.closeAnim = Math.min(1, this.closeAnim + 0.2);
            return;
        }
        this.life--;
        let pool = this.owner.team === 'blue' ? enemies : army;
        for(let e of pool) {
            if(Math.hypot(e.x-this.x, e.y-this.y) < 20) {
                this.triggered = true;
                if(e.takeDamage(25)) this.owner.kills++;
                for(let i=0; i<8; i++) particles.push({x:this.x, y:this.y, vx:Math.random()*4-2, vy:Math.random()*4-2, life:20, c:'gray', type:'SPARK'});
                break;
            }
        }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        
        // Trap Base
        ctx.fillStyle = "#333"; ctx.beginPath(); ctx.arc(0,0, 10, 0, 6.28); ctx.fill();
        ctx.strokeStyle = "#111"; ctx.lineWidth=2; ctx.stroke();
        
        // Jaws
        let angle = this.closeAnim * 1.5; // Close angle
        ctx.strokeStyle = "#ccc"; ctx.lineWidth = 2;
        
        // Left Jaw
        ctx.save(); ctx.rotate(angle);
        ctx.beginPath(); ctx.arc(-8, 0, 8, -1.5, 1.5); ctx.stroke();
        ctx.restore();

        // Right Jaw
        ctx.save(); ctx.rotate(-angle);
        ctx.beginPath(); ctx.arc(8, 0, 8, 1.6, 4.7); ctx.stroke();
        ctx.restore();
        
        // Teeth visual hint
        if(this.closeAnim < 0.5) {
            ctx.fillStyle="#aaa";
            ctx.beginPath(); ctx.moveTo(-6, -4); ctx.lineTo(-4, 0); ctx.lineTo(-2, -4); ctx.fill();
            ctx.beginPath(); ctx.moveTo(6, -4); ctx.lineTo(4, 0); ctx.lineTo(2, -4); ctx.fill();
        }

        ctx.restore();
    }
}

class Creature {
    constructor(x, y, team, mutations=[], generation=0, isBaby=false) {
        this.x = x; this.y = y; this.vx = 0; this.vy = 0;
        this.team = team; 
        this.mutations = [...mutations]; 
        
        this.generation = generation;
        let genMult = 1 + (this.generation * 0.05); 
        
        this.isBoss = false; 
        
        let baseHp = 120 + (difficulty*10);
        this.maxHp = Math.floor((baseHp + (50 * this.mutations.length)) * genMult);
        this.hp = this.maxHp;
        
        this.fullSize = 15;
        this.size = isBaby ? 5 : this.fullSize;
        
        this.accel = 0.4 * genMult; 
        this.friction = 0.92;
        
        this.cooldowns = {}; this.poisonStacks=0; this.frozen=0;
        this.angle = 0; this.stretch = 0;
        
        this.kills = 0;
        this.bred = false;
        this.isBaby = isBaby;
        this.growthTimer = 0;
        this.maxGrowth = 3600; 
    }

    makeBoss() {
        this.isBoss = true;
        this.maxHp = 8000 + (difficulty * 500);
        this.hp = this.maxHp;
        this.fullSize = 50;
        this.size = this.fullSize;
    }

    update() {
        if(this.frozen > 0) { this.frozen--; this.vx*=0.8; this.vy*=0.8; return; }
        
        if(this.isBaby) {
            this.growthTimer++;
            this.size = 5 + (this.fullSize - 5) * (this.growthTimer / this.maxGrowth);
            if(this.growthTimer >= this.maxGrowth) {
                this.isBaby = false;
                this.size = this.fullSize;
                for(let k=0; k<10; k++) particles.push({x:this.x, y:this.y, vx:Math.random()*4-2, vy:Math.random()*4-2, life:30, c:'#ffffff', type:'SPARK'});
            }
        }

        let hasTarget = false;
        if(this.team === 'blue' && !this.isBaby && this.kills >= 1 && !this.bred) {
            let mate = this.findMate();
            if(mate) {
                hasTarget = true;
                this.moveTo(mate, true);
                if(Math.hypot(mate.x-this.x, mate.y-this.y) < this.size + mate.size) {
                    this.breed(mate);
                }
            }
        }

        if(!hasTarget) {
            let target = this.findTarget();
            if(target) {
                this.moveTo(target, false);
                this.mutations.forEach((m, i) => { let cd = this.cooldowns['m'+i]||0; if(cd<=0) this.useAbility(m, target, Math.hypot(target.x-this.x, target.y-this.y), 'm'+i); else this.cooldowns['m'+i]--; });
                if(Math.hypot(target.x-this.x, target.y-this.y) < this.size + target.size) {
                    this.collideAttack(target);
                }
            }
        }

        this.vx *= this.friction; this.vy *= this.friction; this.x += this.vx; this.y += this.vy;
        
        if(this.x<40) { this.x=40; this.vx*=-0.5; } if(this.x>canvas.width-40) { this.x=canvas.width-40; this.vx*=-0.5; }
        if(this.y<40) { this.y=40; this.vy*=-0.5; } if(this.y>canvas.height-40) { this.y=canvas.height-40; this.vy*=-0.5; }
        
        let speed = Math.hypot(this.vx, this.vy); this.stretch = Math.min(speed * 0.05, 0.4);
    }

    moveTo(target, isMate) {
        let dx = target.x - this.x, dy = target.y - this.y;
        let dist = Math.hypot(dx, dy);
        this.angle = Math.atan2(dy, dx);
        
        if(isMate) {
             this.vx += Math.cos(this.angle)*(this.accel*1.5); 
             this.vy += Math.sin(this.angle)*(this.accel*1.5);
             if(Math.random()<0.1) particles.push({x:this.x, y:this.y-20, vx:0, vy:-1, life:40, c:'pink', type:'HEART'});
        } else {
            let isRanged = this.mutations.some(m => MUTATIONS[m]?.type === 'range' || ULTRA_MUTATIONS[m] || ['LASER','SNIPER','PLASMA'].includes(m));
            let optimal = isRanged ? 250 : 0;
            if(dist > optimal) { this.vx += Math.cos(this.angle)*this.accel; this.vy += Math.sin(this.angle)*this.accel; }
            else if(isRanged && dist < optimal - 50) { this.vx -= Math.cos(this.angle)*(this.accel*0.5); this.vy -= Math.sin(this.angle)*(this.accel*0.5); }
        }
    }

    collideAttack(target) {
        let force = 4; let angle = Math.atan2(this.y-target.y, this.x-target.x);
        this.vx += Math.cos(angle)*force; this.vy += Math.sin(angle)*force;
        target.vx -= Math.cos(angle)*force; target.vy -= Math.sin(angle)*force;
        let dmg = 2; if(this.mutations.includes('SPIKES')) dmg+=10; if(this.mutations.includes('SAW')) dmg+=15;
        let killed = target.takeDamage(dmg);
        if(killed) this.kills++;
    }

    findTarget() {
        let pool = this.team==='blue' ? enemies : army;
        let best=null, min=9999;
        for(let e of pool) {
            if(e.mutations.includes('STEALTH')) { if(Math.hypot(e.x-this.x, e.y-this.y) > 100) continue; }
            let d=Math.hypot(e.x-this.x, e.y-this.y); 
            if(d<min){min=d; best=e;} 
        }
        return best;
    }

    findMate() {
        let best=null, min=9999;
        for(let a of army) {
            if(a === this) continue;
            if(a.kills >= 1 && !a.bred && !a.isBaby) {
                let d = Math.hypot(a.x-this.x, a.y-this.y);
                if(d < min) { min = d; best = a; }
            }
        }
        return best;
    }

    breed(mate) {
        this.bred = true; mate.bred = true;
        let childMuts = [];
        let getBest = (list) => {
            if(list.length === 0) return null;
            let ultras = list.filter(m => ULTRA_MUTATIONS[m]);
            if(ultras.length > 0) return ultras[Math.floor(Math.random()*ultras.length)];
            return list[Math.floor(Math.random()*list.length)];
        };
        let m1 = getBest(this.mutations); if(m1) childMuts.push(m1);
        let m2 = getBest(mate.mutations); if(m2 && !childMuts.includes(m2)) childMuts.push(m2);
        
        let baby = new Creature(this.x, this.y, 'blue', childMuts, Math.max(this.generation, mate.generation) + 1, true);
        baby.vx = (Math.random()-0.5)*10; baby.vy = (Math.random()-0.5)*10;
        army.push(baby);

        for(let k=0; k<20; k++) particles.push({x:this.x, y:this.y, vx:Math.random()*4-2, vy:Math.random()*4-2, life:50, c:'pink', type:'HEART'});
    }

    useAbility(key, target, dist, cdKey) {
        if(['LASER','SNIPER','MISSILE','SHOTGUN','FLAME','RICOCHET', 'PLASMA', 'BOOMERANG'].includes(key)) {
            let count = key==='SHOTGUN'?3:1;
            for(let i=0; i<count; i++) { let off = (i- (count-1)/2)*0.3; projectiles.push(new Projectile(this, target, key, off)); }
            this.cooldowns[cdKey] = {LASER:40, SNIPER:100, MISSILE:80, SHOTGUN:60, FLAME:4, RICOCHET:45, PLASMA:120, BOOMERANG:90}[key];
        }
        if(key === 'POISON' && dist < 150) {
            for(let i=0; i<5; i++) particles.push({x:this.x, y:this.y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life:60, type:'POISON'});
            let pool = this.team==='blue'?enemies:army; pool.forEach(e => { if(Math.hypot(e.x-this.x,e.y-this.y)<150) if(e.takeDamage(0.5)) this.kills++; });
            this.cooldowns[cdKey] = 60;
        }
        if(key === 'TRAP') {
            traps.push(new Trap(this.x, this.y, this));
            this.cooldowns[cdKey] = 200;
        }
        if(key === 'VORTEX') {
            let pool = this.team==='blue'?enemies:army;
            pool.forEach(e => {
                let d = Math.hypot(e.x-this.x, e.y-this.y);
                if(d < 200) {
                    let a = Math.atan2(this.y-e.y, this.x-e.x);
                    e.vx += Math.cos(a)*5; e.vy += Math.sin(a)*5;
                }
            });
            // Visual
            for(let i=0; i<20; i++) {
                let a = Math.random()*6.28; let r = 50 + Math.random()*100;
                particles.push({x:this.x+Math.cos(a)*r, y:this.y+Math.sin(a)*r, vx:Math.cos(a+3)*5, vy:Math.sin(a+3)*5, life:30, c:'#7700ff', type:'SPARK'});
            }
            this.cooldowns[cdKey] = 300;
        }
    }

    takeDamage(n) {
        if(this.mutations.includes('GHOST') && Math.random() < 0.25) {
            // Dodged
            texts.push(new DamageText(this.x, this.y, "MISS", "#fff"));
            return false;
        }

        this.hp -= n;
        let txtColor = this.team === 'blue' ? '#00ff00' : '#ff0000';
        texts.push(new DamageText(this.x, this.y, n, txtColor));
        if(this.hp <= 0) return true; // Killed
        return false;
    }

    draw(ctxOverride=null) {
        let c = ctxOverride || ctx;
        c.save(); c.translate(this.x, this.y);

        if(this.mutations.includes('STEALTH')) { c.globalAlpha = 0.3; if(Math.random()>0.9) c.translate(Math.random()*4-2, Math.random()*4-2); }
        if(selectedUnits.includes(this)) { c.beginPath(); c.arc(0, 0, this.size+8, 0, 6.28); c.strokeStyle = "#00ffaa"; c.lineWidth=2; c.stroke(); }
        
        let moveAngle = Math.atan2(this.vy, this.vx);
        c.rotate(moveAngle); c.scale(1 + this.stretch, 1 - this.stretch); c.rotate(-moveAngle);
        c.rotate(this.angle);

        // --- SKINS LOGIC ---
        
        if(currentSkin === 'NEON') {
            let glow = this.team === 'blue' ? "cyan" : "#ff0044";
            c.shadowBlur = 10; c.shadowColor = glow; c.strokeStyle = glow; c.lineWidth = 2;
            c.fillStyle = "rgba(0,0,0,0.5)"; 
            c.beginPath(); c.ellipse(0, 0, this.size*1.2, this.size, 0, 0, 6.28); c.stroke(); c.fill();
            c.beginPath(); c.ellipse(3, 0, this.size*0.8, this.size*0.6, 0, 0, 6.28); c.stroke();
            c.fillStyle = "white"; c.shadowBlur = 15; c.shadowColor="white";
            c.beginPath(); c.arc(8, -4, 2, 0, 6.28); c.arc(8, 4, 2, 0, 6.28); c.fill();
            c.shadowBlur = 0; c.strokeStyle = "#ffaa00"; c.beginPath(); c.moveTo(12,-2); c.lineTo(20,0); c.lineTo(12,2); c.stroke();
        } else if (currentSkin === 'GOLD') {
            let grad = c.createLinearGradient(-this.size, -this.size, this.size, this.size);
            grad.addColorStop(0, "#ffd700"); grad.addColorStop(0.5, "#ffaa00"); grad.addColorStop(1, "#886600");
            c.fillStyle = grad;
            c.beginPath(); c.ellipse(0, 0, this.size*1.2, this.size, 0, 0, 6.28); c.fill();
            if(Math.random()>0.9) c.fillStyle="white"; c.fillRect(Math.random()*20-10, Math.random()*20-10, 2, 2);
            c.fillStyle="#fffacd"; c.beginPath(); c.ellipse(3, 0, this.size*0.8, this.size*0.6, 0, 0, 6.28); c.fill();
            c.fillStyle="black"; c.beginPath(); c.arc(8, -4, 2, 0, 6.28); c.arc(8, 4, 2, 0, 6.28); c.fill();
            c.fillStyle="#fff"; c.beginPath(); c.moveTo(12,-2); c.lineTo(20,0); c.lineTo(12,2); c.fill();

        } else if (currentSkin === 'UNDEAD') {
            c.fillStyle = "#4a6b4a"; 
            c.beginPath(); c.ellipse(0, 0, this.size*1.2, this.size, 0, 0, 6.28); c.fill();
            c.strokeStyle = "#333"; c.lineWidth=1; 
            c.beginPath(); c.moveTo(-5, -5); c.lineTo(0, -5); c.stroke();
            c.beginPath(); c.moveTo(-5, 0); c.lineTo(0, 0); c.stroke();
            c.beginPath(); c.moveTo(-5, 5); c.lineTo(0, 5); c.stroke();

            c.fillStyle="#2a3b2a"; c.beginPath(); c.ellipse(3, 0, this.size*0.8, this.size*0.6, 0, 0, 6.28); c.fill();
            c.fillStyle="#aa0000"; c.beginPath(); c.arc(8, -4, 2, 0, 6.28); c.arc(8, 4, 2, 0, 6.28); c.fill(); 
            c.fillStyle="#222"; c.beginPath(); c.moveTo(12,-2); c.lineTo(18,0); c.lineTo(12,2); c.fill();

        } else if (currentSkin === 'MECHA') {
            c.fillStyle = "#556677"; 
            c.fillRect(-this.size, -this.size+2, this.size*2.2, this.size*1.8); 
            c.fillStyle = "#223344"; c.fillRect(-this.size+2, -this.size+4, 2, 2); c.fillRect(-this.size+2, this.size-4, 2, 2);
            c.fillStyle="#778899"; c.fillRect(0, -this.size+5, this.size, this.size*1.5);
            c.fillStyle="#ff0000"; c.shadowBlur=5; c.shadowColor="red"; c.fillRect(8, -6, 4, 12); c.shadowBlur=0;
            c.fillStyle="#333"; c.beginPath(); c.moveTo(12,-2); c.lineTo(20,0); c.lineTo(12,2); c.fill();

        } else {
            let skin = SKINS[currentSkin];
            let hue = this.team === 'blue' ? 200 : 0;
            let sat = this.team === 'blue' ? "80%" : "80%";
            let lightness = Math.min(90, 40 + (this.generation * 8)) + "%";
            let baseColor = `hsl(${hue}, ${sat}, ${lightness})`;
            if(currentSkin === 'CAMO') baseColor = this.team === 'blue' ? "#88aabb" : "#554433";

            let grad = c.createRadialGradient(-5, -5, 2, 0, 0, this.size);
            grad.addColorStop(0, "#fff"); grad.addColorStop(0.3, baseColor); grad.addColorStop(1, "#000");
            c.fillStyle = grad; c.beginPath(); c.ellipse(0, 0, this.size*1.2, this.size, 0, 0, 6.28); c.fill();
            
            c.fillStyle="#f0faff"; c.beginPath(); c.ellipse(3, 0, this.size*0.8, this.size*0.6, 0, 0, 6.28); c.fill();
            c.fillStyle="black"; c.beginPath(); c.arc(8, -4, 2, 0, 6.28); c.arc(8, 4, 2, 0, 6.28); c.fill();
            c.fillStyle="#ffaa00"; c.beginPath(); c.moveTo(12,-2); c.lineTo(20,0); c.lineTo(12,2); c.fill();
        }

        this.mutations.forEach(m => drawDetailedMutation(c, m, this.size));
        if(this.isBoss) { c.fillStyle = "gold"; c.beginPath(); c.moveTo(-10, -15); c.lineTo(-5, -25); c.lineTo(0, -15); c.lineTo(5, -25); c.lineTo(10, -15); c.fill(); }

        c.rotate(-this.angle);
        c.scale(1/(1 + this.stretch), 1/(1 - this.stretch)); 
        
        let hpColor = this.team === 'blue' ? '#00ff00' : '#ff0000';
        c.fillStyle="rgba(0,0,0,0.5)"; c.fillRect(-15, -this.size-15, 30, 4);
        c.fillStyle=hpColor; c.fillRect(-14, -this.size-14, 28*(this.hp/this.maxHp), 2);
        
        if(this.team === 'blue' && !this.isBaby && this.kills >= 1 && !this.bred) {
             c.fillStyle = "pink"; c.font = "12px Arial"; c.fillText("♥", -3, -this.size-20);
        }
        if(this.isBaby) {
            c.fillStyle = "white"; c.fillRect(-10, -this.size-22, 20 * (this.growthTimer/this.maxGrowth), 2);
        }
        
        c.restore();
    }
}

class Projectile {
    constructor(owner, target, type, angleOff=0) {
        this.x = owner.x; this.y = owner.y; this.type = type; this.owner = owner;
        let a = Math.atan2(target.y-owner.y, target.x-owner.x)+angleOff;
        this.vx=Math.cos(a); this.vy=Math.sin(a);
        
        let s = {LASER:12, SNIPER:25, MISSILE:6, RICOCHET:9, FLAME:7, PLASMA:3, BOOMERANG:10}[type] || 10;
        
        this.vx*=s; this.vy*=s; this.life = 60; this.angle = a;
        if(type==='RICOCHET') this.bounces=2;
        if(type==='PLASMA') this.life = 100;
        if(type==='BOOMERANG') { this.life = 60; this.returning = false; }
    }
    update() {
        if(this.type === 'BOOMERANG') {
            if(!this.returning) {
                this.vx *= 0.95; this.vy *= 0.95;
                if(Math.abs(this.vx) < 0.5) { this.returning = true; }
            } else {
                let a = Math.atan2(this.owner.y - this.y, this.owner.x - this.x);
                this.vx += Math.cos(a)*1.5; this.vy += Math.sin(a)*1.5;
                if(Math.hypot(this.owner.x-this.x, this.owner.y-this.y) < 20) this.life = 0;
            }
        }
        
        this.x+=this.vx; this.y+=this.vy; this.life--;
        if(this.type === 'MISSILE') particles.push({x:this.x, y:this.y, vx:0, vy:0, life:10, type:'SMOKE'});
        if(this.type === 'PLASMA') { this.angle += 0.2; }
        else { this.angle = Math.atan2(this.vy, this.vx); }

        let pool = this.owner.team==='blue'?enemies:army;
        
        if(this.type === 'PLASMA') {
             pool.forEach(t => {
                 if(Math.hypot(t.x-this.x, t.y-this.y) < 50) {
                     if(frame%5===0) { 
                         if(t.takeDamage(2)) this.owner.kills++; 
                         ctx.strokeStyle="cyan"; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(t.x, t.y); ctx.stroke();
                     }
                 }
             });
        } 
        else {
            for(let t of pool) {
                if(Math.hypot(t.x-this.x, t.y-this.y) < t.size+15) {
                    let killed = t.takeDamage(10);
                    if(killed) this.owner.kills++; 
                    
                    if(this.type === 'MISSILE') { for(let i=0; i<10; i++) particles.push({x:this.x, y:this.y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:20, type:'FIRE'}); this.life=0; }
                    else if(this.type === 'RICOCHET' && this.bounces>0) { this.bounces--; let next = pool[Math.floor(Math.random()*pool.length)]; let a = Math.atan2(next.y-this.y, next.x-this.x); this.vx = Math.cos(a)*9; this.vy = Math.sin(a)*9; this.life+=20; }
                    else if(this.type !== 'BOOMERANG') { this.life=0; } 
                    
                    t.vx += this.vx * 0.2; t.vy += this.vy * 0.2; 
                    if(this.type !== 'PLASMA') break;
                }
            }
        }
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        if(this.type === 'LASER') { ctx.shadowBlur = 10; ctx.shadowColor = "red"; ctx.fillStyle = "white"; ctx.fillRect(-10, -1, 20, 2); }
        else if(this.type === 'SNIPER') { ctx.shadowBlur = 5; ctx.shadowColor = "cyan"; ctx.fillStyle = "cyan"; ctx.fillRect(-15, -1, 30, 2); }
        else if(this.type === 'MISSILE') { ctx.fillStyle = "gray"; ctx.beginPath(); ctx.moveTo(5,0); ctx.lineTo(-5, 3); ctx.lineTo(-5, -3); ctx.fill(); }
        else if(this.type === 'RICOCHET') { ctx.fillStyle = "magenta"; ctx.beginPath(); ctx.arc(0,0, 4, 0, 6.28); ctx.fill(); }
        else if(this.type === 'FLAME') { ctx.fillStyle = `rgba(255, ${Math.random()*200}, 0, 0.7)`; ctx.beginPath(); ctx.arc(0,0, 5+Math.random()*5, 0, 6.28); ctx.fill(); }
        else if(this.type === 'PLASMA') { 
            ctx.shadowBlur=15; ctx.shadowColor="#00aaff"; ctx.strokeStyle="white"; ctx.lineWidth=2; 
            ctx.beginPath(); ctx.arc(0,0, 8, 0, 6.28); ctx.stroke();
            ctx.fillStyle="rgba(0,100,255,0.5)"; ctx.fill();
        }
        else if(this.type === 'BOOMERANG') {
            ctx.rotate(frame*0.5);
            ctx.fillStyle = "#8b4513"; ctx.beginPath(); ctx.moveTo(-2,-10); ctx.quadraticCurveTo(8,0,-2,10); ctx.lineTo(2,10); ctx.quadraticCurveTo(12,0,2,-10); ctx.fill();
        }
        ctx.restore();
    }
}

function resolveCollisions() {
    let all = [...army, ...enemies];
    for(let i=0; i<all.length; i++) {
        for(let j=i+1; j<all.length; j++) {
            let u1 = all[i], u2 = all[j];
            let dx = u2.x - u1.x, dy = u2.y - u1.y; let dist = Math.hypot(dx, dy); let minDist = u1.size + u2.size;
            if(dist < minDist) {
                let angle = Math.atan2(dy, dx); let push = (minDist - dist) / 2;
                u1.x -= Math.cos(angle)*push; u1.y -= Math.sin(angle)*push; u2.x += Math.cos(angle)*push; u2.y += Math.sin(angle)*push;
                if(Math.hypot(u1.vx,u1.vy)>1 || Math.hypot(u2.vx,u2.vy)>1) { let tvx = u1.vx, tvy = u1.vy; u1.vx = u2.vx*0.8; u1.vy = u2.vy*0.8; u2.vx = tvx*0.8; u2.vy = tvy*0.8; }
            }
        }
    }
}

// --- GAME LOGIC ---

function initGame() {
    army = []; enemies = []; items = []; projectiles = []; particles = []; texts = []; traps = [];
    Object.keys(MUTATIONS).forEach(k => inventory[k]=0);
    Object.keys(ULTRA_MUTATIONS).forEach(k => inventory[k]=0);
    inventory['LASER'] = 5;
    
    let mutationKeys = Object.keys(MUTATIONS);
    for(let i=0; i<9; i++) {
        let startMuts = [];
        if(i < 3) startMuts.push(mutationKeys[Math.floor(Math.random() * mutationKeys.length)]);
        army.push(new Creature(100+Math.random()*100, 200+Math.random()*300, 'blue', startMuts));
    }
    
    frame=0; biomass=1000; difficulty=1; bossTimer = 0;
    gameState='PLAYING';
    renderInventory();
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('boss-warning').style.display = 'none';
}

function startGame() {
    initGame();
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('exit-btn').style.display = 'block';
    loop();
}

function retryGame() {
    initGame();
    loop();
}

function spawnBoss() {
    let boss = new Creature(canvas.width - 50, canvas.height/2, 'red', ['GIGA_LASER', 'SPIKES', 'METEOR']);
    boss.makeBoss();
    enemies.push(boss);
    texts.push(new DamageText(boss.x, boss.y, "BOSS SPAWNED", "red"));
}

function loop() {
    if(gameState !== 'PLAYING') return;
    
    if(army.length === 0) {
        gameState = 'GAMEOVER';
        document.getElementById('game-over').style.display = 'flex';
        return;
    }

    frame++;
    ctx.clearRect(0,0, canvas.width, canvas.height);
    
    let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 200, canvas.width/2, canvas.height/2, canvas.width);
    grad.addColorStop(0, "#dbeeff"); grad.addColorStop(1, "#88aacc");
    ctx.fillStyle = grad; ctx.fillRect(0,0, canvas.width, canvas.height);
    
    if(frame%60===0) biomass+=5;
    
    bossTimer++;
    if(bossTimer > BOSS_INTERVAL - 300) { 
         let warning = document.getElementById('boss-warning');
         warning.style.display = (Math.floor(frame/30)%2===0) ? 'block' : 'none';
    }
    if(bossTimer >= BOSS_INTERVAL) {
        spawnBoss();
        bossTimer = 0;
        document.getElementById('boss-warning').style.display = 'none';
    }

    document.getElementById('bioDisplay').innerText = biomass;
    document.getElementById('diff-disp').innerText = difficulty + Math.floor(frame/3600);
    document.getElementById('pop-disp').innerText = army.length;

    if(enemies.length < 5 + difficulty && Math.random() < 0.02) {
        let muts = [];
        if(Math.random() < 0.3) muts.push(Object.keys(MUTATIONS)[Math.floor(Math.random()*Object.keys(MUTATIONS).length)]);
        enemies.push(new Creature(canvas.width, Math.random()*canvas.height, 'red', muts));
    }

    traps.forEach((t, i) => { t.update(); t.draw(ctx); if(t.life<=0) traps.splice(i,1); });
    [...army, ...enemies].forEach(c => c.update());
    resolveCollisions();
    [...army, ...enemies].forEach(c => c.draw());
    projectiles.forEach((p, i) => { p.update(); p.draw(); if(p.life<=0) projectiles.splice(i,1); });
    
    particles.forEach((p, i) => { 
        p.x+=p.vx; p.y+=p.vy; p.life--; 
        if(p.type==='POISON') { ctx.fillStyle=`rgba(0,255,0,${p.life/60})`; ctx.beginPath(); ctx.arc(p.x,p.y,10,0,6.28); ctx.fill(); }
        else if(p.type==='FIRE') { ctx.fillStyle=`rgba(255,100,0,${p.life/20})`; ctx.fillRect(p.x,p.y,4,4); }
        else if(p.type==='SMOKE') { ctx.fillStyle=`rgba(100,100,100,${p.life/20})`; ctx.beginPath(); ctx.arc(p.x,p.y,3,0,6.28); ctx.fill(); }
        else if(p.type==='HEART') { ctx.fillStyle=`rgba(255,100,180,${p.life/40})`; ctx.font="12px Arial"; ctx.fillText("♥", p.x, p.y); }
        else if(p.type==='SPARK') { ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,2,2); }
        else { ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,3,3); }
        if(p.life<=0) particles.splice(i,1);
    });

    for(let i=enemies.length-1; i>=0; i--) {
        if(enemies[i].hp<=0) {
            if(enemies[i].mutations.length>0) items.push({x:enemies[i].x, y:enemies[i].y, type:enemies[i].mutations[0], life:2000});
            for(let k=0; k<15; k++) particles.push({x:enemies[i].x, y:enemies[i].y, vx:Math.random()*6-3, vy:Math.random()*6-3, life:40, c:'red', type:'SPARK'});
            enemies.splice(i,1);
        }
    }
    
    for(let i=army.length-1; i>=0; i--) if(army[i].hp <= 0) army.splice(i,1);

    items.forEach((it, i) => {
        let color = (it.isUltra?ULTRA_MUTATIONS:MUTATIONS)[it.type].color;
        let scale = 1 + Math.sin(frame*0.1)*0.2;
        ctx.save(); ctx.translate(it.x, it.y);
        ctx.globalAlpha = 0.5; ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, 15*scale, 0, 6.28); ctx.stroke(); ctx.globalAlpha = 1.0;
        ctx.scale(1.5, 1.5); ctx.shadowBlur=15; ctx.shadowColor = color; ctx.fillStyle = color; ctx.fillRect(-3, -8, 6, 16); ctx.fillStyle="#fff"; ctx.fillRect(-3,-8,6,2);
        ctx.restore();
        if(Math.hypot(mouseX-it.x, mouseY-it.y)<40) { inventory[it.type]++; items.splice(i,1); renderInventory(); }
    });

    texts.forEach((t, i) => { t.update(); t.draw(ctx); if(t.life <= 0) texts.splice(i, 1); });

    if(isDragging) { ctx.strokeStyle="#00ffaa"; ctx.strokeRect(dragStart.x, dragStart.y, mouseX-dragStart.x, mouseY-dragStart.y); }
    if(selectedUnits.length === 1) updateInspectorPanel(selectedUnits[0]);
    requestAnimationFrame(loop);
}

// --- MENUS & HELPERS ---
function goToMenu() { gameState = 'MENU'; document.getElementById('start-menu').style.display='flex'; document.getElementById('exit-btn').style.display='none'; document.getElementById('game-over').style.display='none'; }
function renderInventory() {
    const stdDiv = document.getElementById('dna-inventory'); const ultraDiv = document.getElementById('ultra-inventory');
    stdDiv.innerHTML = ""; ultraDiv.innerHTML = "";
    
    const drawItem = (k, div, isUltra) => {
        if(inventory[k]>0) {
            let el = document.createElement('div'); el.className = "dna-item" + (isUltra?" ultra":"") + (selectedDNA.includes(k)?" selected":"");
            el.innerHTML = `<span style="color:${(isUltra?ULTRA_MUTATIONS:MUTATIONS)[k].color}">${(isUltra?ULTRA_MUTATIONS:MUTATIONS)[k].name}</span> x${inventory[k]}`;
            el.onclick = () => { 
                selectedDNA = [k]; // Simplification for keyboard cycle: allow only 1 selection click
                renderInventory(); updateInspectorButton();
            }; 
            div.appendChild(el);
        }
    };
    Object.keys(MUTATIONS).forEach(k => drawItem(k, stdDiv, false)); Object.keys(ULTRA_MUTATIONS).forEach(k => drawItem(k, ultraDiv, true));
}

function updateInspectorButton() { 
    let btn = document.getElementById('btnInject');
    if(selectedUnits.length>0 && selectedDNA.length>0) {
        let valid = selectedUnits.filter(u => u.mutations.length < 5).length;
        btn.innerText = `INJECT (${valid}/${selectedUnits.length} Valid)`;
    } else {
        btn.innerText = "SELECT UNIT & DNA";
    }
}

function injectMutation() {
    if(selectedUnits.length && selectedDNA.length) {
        let injected = false;
        selectedUnits.forEach(u => { 
            if(u.mutations.length < 5) {
                selectedDNA.forEach(d => { 
                    if(u.mutations.length<5 && inventory[d]>0) { u.mutations.push(d); inventory[d]--; injected=true; } 
                }); 
            }
        });
        if(injected) {
            selectedDNA=[]; renderInventory();
        }
    }
}
function updateInspectorPanel(unit) {
    document.getElementById('inspector-panel').style.display = 'flex';
    document.getElementById('insp-name').innerText = unit.team === 'blue' ? "ALLY PENGUIN" : "ENEMY PENGUIN";
    document.getElementById('insp-name').style.color = unit.team === 'blue' ? "#00ffaa" : "#ff4444";
    document.getElementById('insp-gen').innerText = `Generation: ${unit.generation} | Kills: ${unit.kills}`;
    let pct = Math.max(0, (unit.hp / unit.maxHp) * 100);
    document.getElementById('insp-hp-fill').style.width = pct + "%";
    document.getElementById('insp-hp-fill').style.background = pct > 50 ? "#00ffaa" : "red";
    let slotCont = document.getElementById('insp-slots'); slotCont.innerHTML = "";
    for(let i=0; i<5; i++) {
        let div = document.createElement('div');
        if(i < unit.mutations.length) {
            let k = unit.mutations[i]; let d = MUTATIONS[k] || ULTRA_MUTATIONS[k];
            div.className = "slot filled"; div.innerText = d.name.split(' ')[0]; div.style.borderColor = d.color;
        } else { div.className = "slot empty"; div.innerText = "Empty"; }
        slotCont.appendChild(div);
    }
}

// --- MODALS & SKINS ---
let skinUnit = new Creature(0,0,'blue');
function openSkins() {
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('skins-modal').style.display = 'flex';
    let c = document.getElementById('skinCanvas');
    c.width = document.getElementById('skins-preview').offsetWidth; c.height = document.getElementById('skins-preview').offsetHeight;
    let list = document.getElementById('skin-buttons'); list.innerHTML = "";
    
    Object.keys(SKINS).forEach(key => {
        let b = document.createElement('div');
        b.className = 'sc-btn' + (currentSkin === key ? ' active' : '');
        b.innerText = SKINS[key].name;
        b.onclick = () => { currentSkin = key; openSkins(); };
        list.appendChild(b);
    });
    
    function drawSkinLoop() {
        if(document.getElementById('skins-modal').style.display === 'none') return;
        let ctx = c.getContext('2d');
        ctx.clearRect(0,0,c.width, c.height);
        ctx.save(); ctx.translate(c.width/2, c.height/2); ctx.scale(4,4);
        skinUnit.angle += 0.02; skinUnit.draw(ctx);
        ctx.restore();
        requestAnimationFrame(drawSkinLoop);
    }
    drawSkinLoop();
}

let showcaseMode = false; let showcaseUnit = new Creature(0,0,'blue');
function openShowcase() {
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('showcase-modal').style.display = 'flex';
    let c = document.getElementById('scCanvas');
    c.width = document.getElementById('showcase-preview').offsetWidth; c.height = document.getElementById('showcase-preview').offsetHeight;
    showcaseMode = true; loadShowcaseTabs('std'); showcaseLoop();
}
function loadShowcaseTabs(type) {
    let container = document.getElementById('sc-items'); container.innerHTML = "";
    let data = type === 'std' ? MUTATIONS : ULTRA_MUTATIONS;
    Object.keys(data).forEach(key => {
        let btn = document.createElement('div');
        let isActive = showcaseUnit.mutations.includes(key);
        btn.className = 'sc-btn' + (isActive ? ' active' : '');
        btn.innerHTML = `<b>${data[key].name}</b>`;
        
        btn.onmouseover = () => { document.getElementById('sc-desc').innerText = data[key].desc; document.getElementById('sc-desc').style.color = data[key].color; };
        
        btn.onclick = () => {
            let idx = showcaseUnit.mutations.indexOf(key);
            if(idx > -1) { showcaseUnit.mutations.splice(idx, 1); btn.classList.remove('active'); }
            else if(showcaseUnit.mutations.length < 5) { showcaseUnit.mutations.push(key); btn.classList.add('active'); }
        }; container.appendChild(btn);
    });
}
function showcaseLoop() {
    if(!showcaseMode) return;
    let ctx = document.getElementById('scCanvas').getContext('2d');
    ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = "#334455"; for(let i=0; i<ctx.canvas.width; i+=40) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i, ctx.canvas.height); ctx.stroke(); }
    ctx.save(); ctx.translate(ctx.canvas.width/2, ctx.canvas.height/2); ctx.scale(4, 4); 
    showcaseUnit.angle += 0.02; showcaseUnit.draw(ctx); ctx.restore();
    frame++; requestAnimationFrame(showcaseLoop);
}
function closeModal(id) { document.getElementById(id).style.display = 'none'; document.getElementById('start-menu').style.display = 'flex'; showcaseMode = false; }
function clearShowcase() { showcaseUnit.mutations = []; loadShowcaseTabs('std'); }

// --- CONTROLS ---

let mouseX=0, mouseY=0, isDragging=false, dragStart={x:0,y:0};
canvas.onmousedown = e => { isDragging=true; dragStart={x:e.clientX, y:e.clientY}; };
canvas.onmousemove = e => { mouseX=e.clientX; mouseY=e.clientY; };
canvas.onmouseup = e => { 
    isDragging=false; 
    let dist = Math.hypot(mouseX-dragStart.x, mouseY-dragStart.y);
    if(dist<10) {
        let clicked = army.concat(enemies).find(u => Math.hypot(u.x-mouseX, u.y-mouseY) < u.size + 5);
        if(clicked) { selectedUnits = [clicked]; updateInspectorPanel(clicked); }
        else { selectedUnits = []; document.getElementById('inspector-panel').style.display = 'none'; }
    } else {
        selectedUnits = army.filter(u => u.x>Math.min(dragStart.x,mouseX) && u.x<Math.max(dragStart.x,mouseX) && u.y>Math.min(dragStart.y,mouseY) && u.y<Math.max(dragStart.y,mouseY));
        if(selectedUnits.length===1) updateInspectorPanel(selectedUnits[0]);
    }
    updateInspectorButton();
};

window.onkeydown = (e) => {
    // SHORTCUT: E to cycle DNA
    if(e.key.toLowerCase() === 'e') {
        let available = Object.keys(inventory).filter(k => inventory[k] > 0);
        if(available.length > 0) {
            cycleIndex = (cycleIndex + 1) % available.length;
            selectedDNA = [available[cycleIndex]];
            renderInventory();
            updateInspectorButton();
        }
    }
    // SHORTCUT: Q to Inject
    if(e.key.toLowerCase() === 'q') {
        injectMutation();
    }
};
</script>
</body>
</html>
